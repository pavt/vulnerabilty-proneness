import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import ast
import squarify
import plotly.express as px
import networkx as nx
import scipy.cluster.hierarchy as sch
import community as community_louvain  
import itertools
from itertools import combinations
from collections import Counter

 

class VulnerabilityVisualization:
    def __init__(self, results_handler):
        self.results_handler = results_handler

    def plot_boxplot(self, df):
        """
        Generates and saves a boxplot of high and critical vulnerabilities by category.
        """
        fig, ax = plt.subplots(figsize=(12, 6))
        ax.boxplot(df['vulnerabilities_list'], labels=df['Category'], vert=True,
                   patch_artist=True, boxprops=dict(facecolor="white", color="black"),
                   medianprops=dict(color="orange"))
        plt.xticks(rotation=45, ha='right')
        plt.ylabel('Number of High and Critical Vulnerabilities')
        plt.title('High and Critical Vulnerabilities by Category')
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        self.results_handler.save_plot(fig, "boxplot_vulnerabilities.pdf")

    def plot_histogram(self, df):
        """
        Generates and saves a histogram of vulnerability-proneness.
        """
        sorted_vulnerabilities = [value for sublist in df['vulnerabilities_list'] for value in sublist]
        fig, ax = plt.subplots(figsize=(7, 5))
        ax.hist(sorted_vulnerabilities, bins=50, color='steelblue', edgecolor='black', alpha=0.8)
        plt.title("Sorted Vulnerability-Proneness Histogram")
        plt.xlabel("Vulnerability-Proneness")
        plt.ylabel("Frequency")
        plt.grid(True, linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "histogram_vulnerability_proneness.pdf")

    def plot_category_histograms(self, df):
        """
        Generates and saves probability histograms of vulnerability-proneness for each category.
        """ 
        categories = df['Category'].unique()
        num_categories = len(categories)

        fig, axes = plt.subplots(1, num_categories, figsize=(15, 4), sharex=True, sharey=True)
        colors = plt.cm.viridis(np.linspace(0, 1, num_categories))

        for ax, (category, color) in zip(axes, zip(categories, colors)):
            values = df[df['Category'] == category]['vulnerabilities_list'].iloc[0]
            max_value = max(values)  # Obtener el máximo valor para la categoría actual
            ax.hist(values, bins=20, color=color, alpha=0.7, edgecolor="black", density=True)
            ax.set_title(category, fontsize=10)
            ax.set_xlim(0, max_value + 2)  # Ajustar el límite del eje x al máximo de la categoría
            ax.set_ylim(0, 1)

        plt.suptitle("Probability Histogram of Vulnerability-Proneness by Category", y=1.05, fontsize=14)
        plt.tight_layout()
        self.results_handler.save_plot(fig, "category_histograms.pdf")




    def plot_scatter_vulnerability_vs_components(self, df):
        """
        Generates and saves a scatter plot showing the relationship between Number of Components and Vulnerability-Proneness.
        """
        # Add the required column
        df['Vulnerability-Proneness'] = df['High'] + df['Critical']

        fig, ax = plt.subplots(figsize=(10, 6))
        sns.scatterplot(data=df, x='Number of Components', y='Vulnerability-Proneness', hue='Category',
                        alpha=0.7, edgecolor='black', ax=ax)
        sns.regplot(data=df, x='Number of Components', y='Vulnerability-Proneness', scatter=False,
                    color='red', ci=None, ax=ax)
        ax.set_xscale('log')
        ax.set_yscale('log')
        ax.set_xlabel("Number of Components")
        ax.set_ylabel("Vulnerability-Proneness (High + Critical)")
        ax.set_title("Relationship Between Number of Components and Vulnerability-Proneness (Log Scale)")
        ax.grid(True, linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "scatter_vulnerability_vs_components.pdf")

    def plot_cwe_distribution(self, df):
        """
        Generates and saves a bar plot of the top 15 most common CWE tags.
        """
        cwe_counts = Counter(tag for tags in df['CWE Tags'] for tag in tags)
        cwe_df = pd.DataFrame(cwe_counts.items(), columns=['CWE Tag', 'Frequency']).sort_values(by='Frequency', ascending=False)

        fig, ax = plt.subplots(figsize=(12, 6))
        sns.barplot(data=cwe_df.head(15), x='Frequency', y='CWE Tag', palette='coolwarm', ax=ax)
        ax.set_xlabel("Frequency")
        ax.set_ylabel("CWE Tag")
        ax.set_title("Top 15 Most Common CWE Tags Across Categories")
        ax.grid(axis='x', linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "cwe_distribution.pdf")


    def process_cwe_tags(self, cwe_value, *args):

        # Si ya es una lista, no se modifica
        if isinstance(cwe_value, list):
            return cwe_value
        # Si es una cadena que parece una lista, intenta evaluarla
        elif isinstance(cwe_value, str) and cwe_value.startswith('[') and cwe_value.endswith(']'):
            try:
                return ast.literal_eval(cwe_value)
            except (ValueError, SyntaxError):
                # Si la evaluación falla, retorna una lista vacía o None
                return []
        # Para valores NaN o cualquier otro formato no esperado, retorna lista vacía
        else:
            return []

    def plot_cwe_distribution_by_category(self, df):
        """
        Genera un mapa de burbujas mostrando la relación entre categorías y CWEs.
        """
        # Asegurarse de que 'CWE Tags' está en formato lista de strings
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Crear un DataFrame plano con cada CWE y su categoría asociada
        exploded_df = df.explode('CWE Tags')
        cwe_category_counts = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Obtener el total de acciones por categoría
        category_totals = df['Category'].value_counts().reset_index()
        category_totals.columns = ['Category', 'TotalActions']

        # Combinar el total de acciones con las frecuencias de CWE por categoría
        cwe_category_counts = cwe_category_counts.merge(category_totals, on='Category')

        # Normalizar la columna 'Count' dividiendo por el total de acciones
        cwe_category_counts['NormalizedCount'] = cwe_category_counts['Count'] / cwe_category_counts['TotalActions']

        # Crear el gráfico de burbujas con los valores normalizados
        fig, ax = plt.subplots(figsize=(12, 8))
        scatter = ax.scatter(
            x=cwe_category_counts['Category'],
            y=cwe_category_counts['CWE Tags'],
            s=cwe_category_counts['NormalizedCount'] * 1000,  # Tamaño proporcional a la frecuencia normalizada
            alpha=0.6,
            edgecolors='w',
            linewidth=0.5
        )

        # Configurar ejes y títulos
        ax.set_title('Distribución Normalizada de CWEs por Categoría (Mapa de Burbujas)', fontsize=14)
        ax.set_xlabel('Categoría', fontsize=12)
        ax.set_ylabel('CWE', fontsize=12)
        ax.grid(True, linestyle='--', alpha=0.5)
        plt.xticks(rotation=45, ha='right')

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "cwe_bubble_map_by_category_normalized.pdf")



    def plot_cwe_distribution_by_frequency(self, df, min_frequency=5):
        """
        Generates a horizontal bar chart showing the frequency distribution of CWEs in the dataset.
        """
        # Normalize 'CWE Tags' to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode the DataFrame to work with individual CWEs
        exploded_df = df.explode('CWE Tags')

        # Count the frequency of each CWE
        cwe_counts = exploded_df['CWE Tags'].value_counts().reset_index()
        cwe_counts.columns = ['CWE', 'Count']

        # Filter out low-frequency CWEs for better visualization
        cwe_counts = cwe_counts[cwe_counts['Count'] >= min_frequency]

        # Create the horizontal bar chart
        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(
            data=cwe_counts, 
            x='Count', 
            y='CWE', 
            palette='coolwarm', 
            ax=ax
        )

        # Configure axes and titles
        ax.set_title('CWE Distribution by Frequency (Bar Chart)', fontsize=14)
        ax.set_xlabel('Occurrence Count', fontsize=12)
        ax.set_ylabel('CWE', fontsize=12)
        ax.grid(axis='x', linestyle='--', alpha=0.5)

        # Save the plot
        self.results_handler.save_plot(fig, "cwe_bar_chart_by_frequency.pdf")




    def plot_cwe_distribution_violinplot(self, df, min_frequency=1):
        """
        Generates a violin plot showing the distribution of CWE occurrences across different categories.
        """
        # Normalize 'CWE Tags' to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode the DataFrame to work with individual CWEs
        exploded_df = df.explode('CWE Tags')

        # Count occurrences of each CWE within each category
        cwe_category_counts = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Filter out low-frequency CWEs for better visualization
        cwe_category_counts = cwe_category_counts[cwe_category_counts['Count'] >= min_frequency]

        # Create the violin plot
        fig, ax = plt.subplots(figsize=(14, 8))
        sns.violinplot(
            data=cwe_category_counts, 
            x='Category', 
            y='Count', 
            scale='width', 
            inner='quartile', 
            palette='coolwarm', 
            ax=ax
        )

        # Configure axes and titles
        ax.set_title('CWE Distribution by Category (Violin Plot)', fontsize=14)
        ax.set_xlabel('Category', fontsize=12)
        ax.set_ylabel('CWE Occurrence Count', fontsize=12)
        ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')
        ax.grid(axis='y', linestyle='--', alpha=0.5)

        # Save the plot
        self.results_handler.save_plot(fig, "cwe_violin_plot_by_category.pdf")




    def plot_vulnerability_distribution(self, df):
        """
        Generates histograms and density plots showing the frequency of vulnerabilities per category.
        This visualization helps analyze the prevalence of vulnerabilities across different action categories.
        """
        # Convert 'Total Vulnerabilities' to numeric if not already
        df['Total Vulnerabilities'] = pd.to_numeric(df['Total Vulnerabilities'], errors='coerce')

        # Set up the figure with subplots for histogram and density plot
        fig, axes = plt.subplots(1, 2, figsize=(14, 6), sharex=False)

        # Histogram of total vulnerabilities per category
        sns.histplot(data=df, x='Total Vulnerabilities', hue='Category', bins=30, kde=False, ax=axes[0], multiple="stack")
        axes[0].set_title("Histogram of Total Vulnerabilities per Category")
        axes[0].set_xlabel("Total Vulnerabilities")
        axes[0].set_ylabel("Frequency")
        axes[0].grid(axis='y', linestyle='--', alpha=0.5)

        # Density plot (Kernel Density Estimation) to see the smooth distribution
        sns.kdeplot(data=df, x='Total Vulnerabilities', hue='Category', fill=True, common_norm=False, alpha=0.5, ax=axes[1])
        axes[1].set_title("Density Plot of Vulnerabilities per Category")
        axes[1].set_xlabel("Total Vulnerabilities")
        axes[1].set_ylabel("Density")
        axes[1].grid(axis='y', linestyle='--', alpha=0.5)

        # Adjust layout and save the plot
        plt.tight_layout()
        self.results_handler.save_plot(fig, "vulnerability_distribution_hist_density.pdf")




    def plot_vulnerability_bubble_scatter(self, df):
        """
        Generates a Bubble Map and a Scatter Plot to visualize relationships between categories and vulnerabilities.
        - Bubble Map: Shows normalized vulnerabilities across categories.
        - Scatter Plot: Examines relationships between two vulnerability-related attributes (e.g., Total Vulnerabilities vs. Number of Components).
        """

        # Normalize total vulnerabilities for better scaling in bubble size
        df['Total Vulnerabilities'] = pd.to_numeric(df['Total Vulnerabilities'], errors='coerce')
        df['Normalized Vulnerabilities'] = df.groupby('Category')['Total Vulnerabilities'].transform(lambda x: x / x.max())

        # Set up the figure with subplots
        fig, axes = plt.subplots(1, 2, figsize=(14, 6))

        # ---- Bubble Map (Improved) ----
        bubble_df = df.groupby("Category", as_index=False).agg(
            {"Total Vulnerabilities": "sum", "Number of Components": "mean"}
        )
        bubble_df['Bubble Size'] = bubble_df["Total Vulnerabilities"] / bubble_df["Total Vulnerabilities"].max() * 1000  # Scale size

        sns.scatterplot(
            data=bubble_df,
            x="Category",
            y="Total Vulnerabilities",
            size="Bubble Size",
            sizes=(10, 1000),
            alpha=0.6,
            ax=axes[0]
        )
        axes[0].set_xticklabels(axes[0].get_xticklabels(), rotation=45, ha="right")
        axes[0].set_title("Bubble Map: Normalized Vulnerabilities by Category")
        axes[0].set_xlabel("Category")
        axes[0].set_ylabel("Total Vulnerabilities")
        axes[0].grid(True, linestyle="--", alpha=0.5)

        # ---- Scatter Plot ----
        sns.scatterplot(
            data=df,
            x="Number of Components",
            y="Total Vulnerabilities",
            hue="Category",
            size="Total Vulnerabilities",
            sizes=(10, 300),
            alpha=0.6,
            ax=axes[1]
        )
        axes[1].set_xscale("log")  # Log scale for better visibility if needed
        axes[1].set_yscale("log")
        axes[1].set_title("Scatter Plot: Components vs. Vulnerabilities")
        axes[1].set_xlabel("Number of Components (Log Scale)")
        axes[1].set_ylabel("Total Vulnerabilities (Log Scale)")
        axes[1].grid(True, linestyle="--", alpha=0.5)

        # Adjust layout and save the plot
        plt.tight_layout()
        self.results_handler.save_plot(fig, "vulnerability_bubble_scatter.pdf")



    def plot_cwe_category_heatmap(self, df, top_cwes=20, top_categories=12, fontsize=14):
        """
        Generates a heatmap to visualize the intensity of the most frequent CWEs per category.

        - The x-axis represents the top N vulnerability categories (sorted in ascending order).
        - The y-axis represents the top N most frequent CWE tags.
        - Color intensity indicates the frequency of each CWE in a given category.
        """

        import pandas as pd
        import matplotlib.pyplot as plt
        import seaborn as sns

        # Ensure 'CWE Tags' is parsed correctly
        #df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)
        df['CWE Tags'] = df['CWE Tags'].apply(lambda x: [tag.upper() for tag in self.process_cwe_tags(x)])

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Exclude rows where CWE Tag is "N/A"
        exploded_df = exploded_df[exploded_df['CWE Tags'] != "N/A"]

        # Count total occurrences of each CWE
        cwe_counts = exploded_df['CWE Tags'].value_counts()

        # Select the top N most frequent CWE tags
        top_cwe_list = cwe_counts.nlargest(top_cwes).index

        # Filter the data to include only the selected CWE tags
        filtered_df = exploded_df[exploded_df['CWE Tags'].isin(top_cwe_list)]

        # Count total occurrences of each category
        category_counts = filtered_df['Category'].value_counts()

        # Select the top N categories with the highest CWE occurrences
        top_category_list = category_counts.nlargest(top_categories).index

        # Filter the data to include only the selected categories
        filtered_df = filtered_df[filtered_df['Category'].isin(top_category_list)]

        # Create a pivot table counting CWEs per category
        heatmap_data = filtered_df.groupby(['CWE Tags', 'Category']).size().unstack(fill_value=0)

        # Sort categories in ascending order (left to right)
        category_order = heatmap_data.sum(axis=0).sort_values(ascending=True).index
        heatmap_data = heatmap_data[category_order]  # Reorder matrix

        # Normalize each row by its maximum value for better comparability
        heatmap_data = heatmap_data.div(heatmap_data.max(axis=1), axis=0)

        # Create the heatmap without a color bar
        fig, ax = plt.subplots(figsize=(12, 9))
        sns.heatmap(
            heatmap_data, 
            cmap= "Greys", #"Blues", 
            cbar=False,  # Remove the color bar (legend)
            ax=ax
        )  

        # Increase font size for axis labels
        ax.set_xlabel("", fontsize=fontsize)
        ax.set_ylabel("", fontsize=fontsize)

        # Increase tick label font size
        ax.tick_params(axis='both', labelsize=fontsize)

        # Increase font size for X-axis tick labels (Categories)
        category_labels = [label.replace(" ", "\n") if len(label) > 15 else label for label in category_order]
        ax.set_xticklabels(category_labels, fontsize=fontsize, rotation=45, ha='right')

        # Increase font size for Y-axis tick labels (CWE Tags)
        ax.set_yticklabels(ax.get_yticklabels(), fontsize=fontsize)

        # Automatically adjust layout to prevent cuts
        plt.tight_layout()

        # Remove extra margins
        plt.margins(0)  

        # Save the figure manually with bbox_inches="tight" before calling save_plot()
        plot_path = "cwe_category_heatmap_filtered.pdf"
        fig.savefig(plot_path, bbox_inches="tight")

        # Use save_plot without bbox_inches
        self.results_handler.save_plot(fig, plot_path)

        print(f"Plot saved: {plot_path} (Top {top_cwes} CWEs, Top {top_categories} Categories)")












    def plot_cwe_category_treemap(self, df):
        """
        Generates a treemap to visualize the hierarchical distribution of CWEs within categories.

        - Each category is represented as a large rectangle.
        - Each CWE within a category is a sub-rectangle.
        - The size of each rectangle represents the frequency of occurrences.
        """

        # Ensure 'CWE Tags' is processed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Count CWEs per category
        treemap_data = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Create a treemap
        fig = px.treemap(treemap_data, 
                        path=['Category', 'CWE Tags'], 
                        values='Count', 
                        color='Count',
                        color_continuous_scale='Blues',
                        title="Treemap: Hierarchical Distribution of CWEs within Categories")

        # Save the plot
        fig.write_image(f"{self.results_handler.results_path}/cwe_category_treemap.pdf")
        print("Treemap saved: cwe_category_treemap.pdf")


    def plot_cwe_category_sunburst(self, df):
        """
        Generates a sunburst chart to visualize the hierarchical structure of CWEs within categories.

        - The inner circle represents categories.
        - The outer circles represent CWEs under those categories.
        - The size of each slice represents the frequency of occurrences.
        """

        # Ensure 'CWE Tags' is processed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Count CWEs per category
        sunburst_data = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Create a sunburst chart
        fig = px.sunburst(sunburst_data, 
                        path=['Category', 'CWE Tags'], 
                        values='Count', 
                        color='Count',
                        color_continuous_scale='Blues',
                        title="Sunburst Chart: CWE Hierarchy within Categories")

        # Save the plot
        fig.write_image(f"{self.results_handler.results_path}/cwe_category_sunburst.pdf")
        print("Sunburst Chart saved: cwe_category_sunburst.pdf")


    def plot_cwe_cooccurrence_matrix(self, df, min_occurrences=10):
        """
        Generates a co-occurrence matrix for CWEs, filtering only the most frequent ones.
        """
        import seaborn as sns
        import numpy as np
        import pandas as pd
        from itertools import combinations
        import matplotlib.pyplot as plt
        
        # Convert CWE Tags column to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)
        
        # Explode CWE Tags to count frequency of each CWE
        all_cwes = df.explode('CWE Tags')['CWE Tags']
        cwe_counts = all_cwes.value_counts()
        
        # Filter CWEs that appear at least 'min_occurrences' times
        frequent_cwes = list(cwe_counts[cwe_counts >= min_occurrences].index)  # Convert to list
        
        # Extract CWE pairs from filtered rows
        cwe_pairs = []
        for cwes in df['CWE Tags']:
            filtered_cwes = [cwe for cwe in cwes if cwe in frequent_cwes]
            cwe_pairs.extend(combinations(filtered_cwes, 2))
        
        # Build co-occurrence matrix
        cwe_cooccurrence = pd.DataFrame(0, index=frequent_cwes, columns=frequent_cwes)
        for cwe1, cwe2 in cwe_pairs:
            cwe_cooccurrence.at[cwe1, cwe2] += 1
            cwe_cooccurrence.at[cwe2, cwe1] += 1  # Symmetric matrix
        
        # Create heatmap figure
        fig, ax = plt.subplots(figsize=(12, 10))  # Ensure 'fig' is properly assigned
        sns.heatmap(cwe_cooccurrence, cmap='Blues', annot=False, linewidths=0.5, ax=ax)
        ax.set_title('CWE Co-Occurrence Matrix (Filtered)')
        plt.xticks(rotation=45, ha='right')
        plt.yticks(rotation=0)
        
        # Save plot using 'fig' instead of 'plt'
        self.results_handler.save_plot(fig, "cwe_cooccurrence_matrix_filtered.pdf")

 




    def plot_vulnerability_proneness_comparison(self, file_path_source, file_path_all):
        """
        Generates a boxplot comparing Vulnerability-Proneness between source code and dependencies.
        Extreme outliers are capped using clip() to improve visualization.
        """
        import matplotlib.pyplot as plt
        import seaborn as sns
        import pandas as pd
        import numpy as np
        import matplotlib.cm as cm

        # Load the datasets
        df_source = pd.read_csv(file_path_source)
        df_all = pd.read_csv(file_path_all)

        # Assign explicit columns for Vulnerability-Proneness
        df_source["Vulnerability-Proneness"] = df_source["vulnerability-proneness-source"]
        df_all["Vulnerability-Proneness"] = df_all["vulnerability-proneness-all"]

        # Convert categories to uppercase
        df_source["Category"] = df_source["Category"].str.upper()
        df_all["Category"] = df_all["Category"].str.upper()

        # Label the datasets
        df_source["Data Source"] = "SOURCE ONLY"
        df_all["Data Source"] = "SOURCE + DEPENDENCIES (VULNERABILITY-PRONENESS)"

        # Combine datasets
        df_combined = pd.concat([
            df_source[["Category", "Vulnerability-Proneness", "Data Source"]],
            df_all[["Category", "Vulnerability-Proneness", "Data Source"]]
        ])

        # Filter categories with at least 10 actions
        category_counts = df_combined.groupby('Category').size()
        MIN_ACTIONS = 10
        categories_to_keep = category_counts[category_counts >= MIN_ACTIONS].index
        df_filtered = df_combined[df_combined['Category'].isin(categories_to_keep)]

        # **Capping Extreme Outliers at 40**
        df_filtered["Vulnerability-Proneness"] = df_filtered["Vulnerability-Proneness"].clip(upper=40)

        # Order categories by median Vulnerability-Proneness
        category_medians = df_filtered.groupby('Category')['Vulnerability-Proneness'].median().sort_values()
        ordered_categories = category_medians.index
        df_filtered['Category'] = pd.Categorical(df_filtered['Category'], categories=ordered_categories, ordered=True)

        # Create figure with optimized size and resolution
        fig, ax = plt.subplots(figsize=(15, 8), dpi=300)
        fig.patch.set_facecolor("white")  # Light gray background
        ax.set_facecolor("white")  # White plot background

        # Generate grayscale colors
        grayscale_colors = [cm.Greys(0.3), cm.Greys(0.7)]  # Two shades of gray

        # Create the boxplot using grayscale palette
        sns.boxplot(
            x="Category",
            y="Vulnerability-Proneness",
            hue="Data Source",
            data=df_filtered,
            palette=grayscale_colors,  # Apply grayscale colors
            width=0.7,
            fliersize=4,  # Keep mild outliers
            flierprops=dict(marker='o', markerfacecolor='white', markeredgecolor='darkorange', markersize=5),  # Orange outliers
            medianprops=dict(color="darkorange", linewidth=2),

            ax=ax
        )

        # Customize labels and title
        plt.xlabel("", fontweight='bold', labelpad=10)
        plt.ylabel("VULNERABILITY-PRONENESS", fontweight='bold', labelpad=10)

        # Remove extra grid and unnecessary lines
        ax.spines["top"].set_visible(False)
        ax.spines["right"].set_visible(False)

        # Customize legend
        plt.legend(
            title="DATA SOURCE",
            title_fontsize=12,
            fontsize=10,
            loc='upper left',
            framealpha=0.9,
            edgecolor='gray'
        )

        # Rotate x-axis labels and adjust layout
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()

        # Remove extra margins
        plt.margins(0)

        # Save the figure manually with bbox_inches="tight" to remove whitespace
        plot_path = "vulnerability_proneness_comparison.pdf"
        fig.savefig(plot_path, bbox_inches="tight", pad_inches=0)

        # Use save_plot without bbox_inches
        self.results_handler.save_plot(fig, plot_path)

        print("Plot saved:", plot_path)







    def plot_vulnerability_components_relationship_logscale(self, file_path_source, file_path_all):
        """
        Genera un scatter plot comparando el número de componentes y el incremento en 
        Vulnerability-Proneness (diferencia entre 'vulnerability-proneness-all' y 'vulnerability-proneness-source'),
        aplicando escala logarítmica en ambos ejes. Solo se incluyen categorías con al menos 3 repositorios.
        """

        # Configurar el estilo de matplotlib
        plt.style.use('seaborn-v0_8-darkgrid')
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_aggregated = pd.read_csv(file_path_all)

        # Preparar los datos: seleccionar las columnas relevantes
        df_source = df_source[['repo_owner', 'repo_name', 'Category', 'vulnerability-proneness-source']]
        df_aggregated = df_aggregated[['repo_owner', 'repo_name', 'Category', 'Number of Components', 'vulnerability-proneness-all']]

        # Merge de ambos conjuntos de datos basado en repositorio y categoría
        df_merged = pd.merge(df_source, df_aggregated, on=['repo_owner', 'repo_name', 'Category'], how="inner")

        # Calcular el incremento de vulnerabilidad: diferencia entre aggregated y source
        df_merged['vulnerability_increase'] = df_merged['vulnerability-proneness-all'] - df_merged['vulnerability-proneness-source']

        # Filtrar categorías con al menos MIN_REPOS repositorios
        category_counts = df_merged['Category'].value_counts()
        MIN_REPOS = 3
        categories_to_keep = category_counts[category_counts >= MIN_REPOS].index
        df_filtered = df_merged[df_merged['Category'].isin(categories_to_keep)]

        # Crear figura con alta resolución
        fig, ax = plt.subplots(figsize=(12, 8), dpi=300)

        # Crear el scatter plot
        scatter = sns.scatterplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            hue="Category",
            palette="deep",
            alpha=0.7,
            s=100,            # Tamaño de los puntos
            edgecolor='white',  # Borde blanco para los puntos
            linewidth=0.5,
            ax=ax
        )

        # Agregar línea de tendencia
        sns.regplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            scatter=False,
            color="#E74C3C",
            line_kws={
                "linewidth": 2,
                "linestyle": "--",
                "alpha": 0.8
            },
            ax=ax
        )

        # Aplicar escala logarítmica a ambos ejes
        ax.set_xscale('log')
        ax.set_yscale('log')

        # Personalizar etiquetas y título
        plt.xlabel("Number of Components (log scale)", fontweight='bold', labelpad=10)
        plt.ylabel("Increase in Vulnerability-Proneness (log scale)", fontweight='bold', labelpad=10)
        plt.title("Component Count vs. Vulnerability-Proneness Increase\n(Scaled Logarithmically)", 
                fontweight='bold', pad=20)

        # Personalizar la leyenda
        legend = plt.legend(
            title="Category",
            title_fontsize=12,
            fontsize=10,
            loc='center left',
            bbox_to_anchor=(1, 0.5),
            frameon=True,
            framealpha=0.9,
            edgecolor='gray'
        )

        # Agregar grid mejorado
        plt.grid(True, linestyle='--', alpha=0.3, color='gray')
        plt.margins(x=0.02)

        # Calcular y mostrar la correlación en escala logarítmica
        # Se utiliza log para ambas variables; si hay ceros o valores negativos, se debe filtrar.
        # Suponemos que Number of Components y vulnerability_increase son positivos.
        correlation = np.corrcoef(np.log(df_filtered["Number of Components"]), np.log(df_filtered["vulnerability_increase"]))[0, 1]
        plt.text(0.02, 0.98, f'Correlation (log): {correlation:.2f}', 
                transform=ax.transAxes, 
                fontsize=10,
                bbox=dict(facecolor='white', edgecolor='gray', alpha=0.8))

        plt.tight_layout()

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_components_relationship_logscale.pdf")
        print("Plot saved: vulnerability_components_relationship_logscale.pdf")

    def plot_vulnerability_components_relationship_logscale(self, file_path_source, file_path_all):
        """
        Genera un scatter plot comparando el número de componentes y el incremento en 
        Vulnerability-Proneness (diferencia entre 'vulnerability-proneness-all' y 'vulnerability-proneness-source'),
        aplicando escala logarítmica en ambos ejes. Solo se incluyen categorías con al menos 3 repositorios.
        """
        import pandas as pd
        import matplotlib.pyplot as plt
        import seaborn as sns
        import numpy as np
        import os

        # Configurar el estilo de matplotlib
        plt.style.use('seaborn-v0_8-darkgrid')
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_aggregated = pd.read_csv(file_path_all)

        # Preparar los datos: seleccionar las columnas relevantes
        df_source = df_source[['repo_owner', 'repo_name', 'Category', 'vulnerability-proneness-source']]
        df_aggregated = df_aggregated[['repo_owner', 'repo_name', 'Category', 'Number of Components', 'vulnerability-proneness-all']]

        # Merge de ambos conjuntos de datos basado en repositorio y categoría
        df_merged = pd.merge(df_source, df_aggregated, on=['repo_owner', 'repo_name', 'Category'], how="inner")

        # Calcular el incremento de vulnerabilidad: diferencia entre aggregated y source
        df_merged['vulnerability_increase'] = df_merged['vulnerability-proneness-all'] - df_merged['vulnerability-proneness-source']

        # Filtrar categorías con al menos MIN_REPOS repositorios
        category_counts = df_merged['Category'].value_counts()
        MIN_REPOS = 3
        categories_to_keep = category_counts[category_counts >= MIN_REPOS].index
        df_filtered = df_merged[df_merged['Category'].isin(categories_to_keep)]

        # Crear figura con alta resolución
        fig, ax = plt.subplots(figsize=(12, 8), dpi=300)

        # Crear el scatter plot
        scatter = sns.scatterplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            hue="Category",
            palette="deep",
            alpha=0.7,
            s=100,            # Tamaño de los puntos
            edgecolor='white',  # Borde blanco para los puntos
            linewidth=0.5,
            ax=ax
        )

        # Agregar línea de tendencia
        sns.regplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            scatter=False,
            color="#E74C3C",
            line_kws={
                "linewidth": 2,
                "linestyle": "--",
                "alpha": 0.8
            },
            ax=ax
        )

        # Aplicar escala logarítmica a ambos ejes
        ax.set_xscale('log')
        ax.set_yscale('log')

        # Personalizar etiquetas y título
        plt.xlabel("Number of Components (log scale)", fontweight='bold', labelpad=10)
        plt.ylabel("Increase in Vulnerability-Proneness (log scale)", fontweight='bold', labelpad=10)
        plt.title("Component Count vs. Vulnerability-Proneness Increase\n(Scaled Logarithmically)", 
                fontweight='bold', pad=20)

        # Personalizar la leyenda
        legend = plt.legend(
            title="Category",
            title_fontsize=12,
            fontsize=10,
            loc='center left',
            bbox_to_anchor=(1, 0.5),
            frameon=True,
            framealpha=0.9,
            edgecolor='gray'
        )

        # Agregar grid mejorado y ajustar márgenes
        plt.grid(True, linestyle='--', alpha=0.3, color='gray')
        plt.margins(x=0.02)

        # Calcular y mostrar la correlación en escala logarítmica
        # Se calcula la correlación entre los logaritmos de los valores (suponiendo que ambos sean positivos)
        correlation = np.corrcoef(np.log(df_filtered["Number of Components"]), np.log(df_filtered["vulnerability_increase"]))[0, 1]
        plt.text(0.02, 0.98, f'Correlation (log): {correlation:.2f}', 
                transform=ax.transAxes, 
                fontsize=10,
                bbox=dict(facecolor='white', edgecolor='gray', alpha=0.8))

        plt.tight_layout()

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_components_relationship_logscale.pdf")
        print("Plot saved: vulnerability_components_relationship_logscale.pdf")


    def plot_cwe_distribution_by_category_stacked(self, file_path, figsize=(6, 5)):
            """
            Genera un stacked bar chart que muestra la distribución de las 10 CWEs críticas
            agrupadas por categoría, utilizando el archivo indicado.
            Las categorías se ordenan de forma ascendente según la suma total de las CWEs críticas.
            Se filtran las categorías que tengan menos de 5 ocurrencias en total.

            Parámetros:
            - file_path: Ruta del archivo CSV con los datos.
            - figsize: Tamaño del gráfico (ancho, alto), por defecto (10, 6).
            """
            import pandas as pd
            import matplotlib.pyplot as plt

            # Cargar el archivo CSV con los datos de vulnerabilidades agregadas
            df = pd.read_csv(file_path)

            # Expandir la columna de 'CWE Tags': convertir la cadena en lista de CWEs
            df['CWE Tags'] = df['CWE Tags'].apply(eval)

            # Definir las 10 CWEs más críticas por su severidad
            critical_cwes = ['CWE-020', 'CWE-200', 'CWE-287', 'CWE-352', 'CWE-74', 
                            'CWE-1333', 'CWE-915', 'CWE-78', 'CWE-400', 'CWE-259']

            # Crear una columna para cada CWE de interés, contando las ocurrencias
            for cwe in critical_cwes:
                df[cwe] = df['CWE Tags'].apply(lambda x: x.count(cwe))

            # Agrupar por categoría y sumar las ocurrencias de cada CWE crítica
            cwe_counts_by_category = df.groupby('Category')[critical_cwes].sum()

            # Filtrar para incluir solo categorías con al menos 5 ocurrencias totales de CWEs
            cwe_counts_by_category = cwe_counts_by_category[
                (cwe_counts_by_category.sum(axis=1) >= 5)
            ]

            # Ordenar las categorías de forma ascendente según la suma total de las ocurrencias
            total_counts = cwe_counts_by_category.sum(axis=1)
            ordered_categories = total_counts.sort_values(ascending=True).index
            cwe_counts_by_category = cwe_counts_by_category.loc[ordered_categories]

            # Crear la figura con tamaño ajustable
            fig, ax = plt.subplots(figsize=figsize)  # <-- Permite ajustar tamaño del gráfico

            # Graficar el stacked bar chart
            cwe_counts_by_category.plot(kind='barh', stacked=True, ax=ax)

            # Ajustar título y etiquetas
            #ax.set_title("Top 10 CWE Across Categories (Critical)", fontsize=10, pad=15)
            ax.set_xlabel("CWE Count", fontsize=8)
            ax.set_ylabel("")  # <-- Se elimina la etiqueta del eje Y

            # Ajustar tamaño de fuente y espaciado en etiquetas
            ax.tick_params(axis="y", labelsize=8, pad=2)  # Reduce el tamaño de las etiquetas y el espacio entre ellas

            # Dividir nombres largos en varias líneas si es necesario
            categories = cwe_counts_by_category.index
            ax.set_yticklabels([cat.replace(" ", "\n") if len(cat) > 15 else cat for cat in categories])

            # Ajustar la leyenda dentro del gráfico en la esquina inferior derecha
            ax.legend(title="CWE Tags", loc='lower right', fontsize=8, frameon=True)

            # Ajustar el layout para evitar cortes
            plt.tight_layout()

            # Guardar la figura
            self.results_handler.save_plot(fig, "cwe_distribution_by_category_stacked.pdf")
            print("Plot saved: cwe_distribution_by_category_stacked.pdf")

    # def plot_cwe_distribution_by_category_stacked(self, file_path, figsize=(6, 5)):
    #     """
    #     Generates a stacked bar chart showing the distribution of the 10 most critical CWEs
    #     grouped by category, using the specified CSV file.
    #     Categories are sorted in ascending order based on total CWE occurrences.
    #     Categories with fewer than 5 occurrences in total are filtered out.
    #
    #     Parameters:
    #     - file_path: Path to the CSV file containing the data.
    #     - figsize: Size of the figure (width, height), default is (6, 5).
    #     """
    #     import pandas as pd
    #     import matplotlib.pyplot as plt
    #     import numpy as np
    #     import matplotlib.cm as cm
    #
    #     # Load the CSV file with aggregated vulnerability data
    #     df = pd.read_csv(file_path)
    #
    #     # Convert categories to uppercase
    #     df['Category'] = df['Category'].str.upper()
    #
    #     # Expand the 'CWE Tags' column: Convert string to a list of CWEs
    #     df['CWE Tags'] = df['CWE Tags'].apply(eval)
    #
    #     # Define the 10 most critical CWEs
    #     critical_cwes = ['cwe-020', 'CWE-200', 'CWE-287', 'CWE-352', 'CWE-74', 
    #                     'CWE-1333', 'CWE-915', 'CWE-78', 'CWE-400', 'CWE-259']
    #
    #     # Create a column for each CWE of interest, counting occurrences
    #     for cwe in critical_cwes:
    #         df[cwe] = df['CWE Tags'].apply(lambda x: x.count(cwe))
    #
    #     # Group by category and sum occurrences of each critical CWE
    #     cwe_counts_by_category = df.groupby('Category')[critical_cwes].sum()
    #
    #     # Filter only categories with at least 5 total CWE occurrences
    #     cwe_counts_by_category = cwe_counts_by_category[
    #         (cwe_counts_by_category.sum(axis=1) >= 5)
    #     ]
    #
    #     # Order categories in ascending order based on total CWE occurrences
    #     total_counts = cwe_counts_by_category.sum(axis=1)
    #     ordered_categories = total_counts.sort_values(ascending=True).index
    #     cwe_counts_by_category = cwe_counts_by_category.loc[ordered_categories]
    #
    #     # Create the figure with adjustable size
    #     fig, ax = plt.subplots(figsize=figsize)
    #
    #     # Generate grayscale colors using Matplotlib's `Greys` colormap
    #     grayscale_colors = cm.Greys(np.linspace(0.3, 0.8, len(critical_cwes)))  # Shades from light gray to dark gray
    #
    #     # Plot the stacked bar chart with grayscale colors
    #     cwe_counts_by_category.plot(kind='barh', stacked=True, ax=ax, color=grayscale_colors)
    #
    #     # Set title and labels
    #     #ax.set_title("TOP 10 CWE ACROSS CATEGORIES (CRITICAL)", fontsize=10, pad=15)
    #     ax.set_xlabel("CWE COUNT", fontsize=8)
    #     ax.set_ylabel("")  # Remove the Y-axis label
    #
    #     # Adjust font size and spacing for labels
    #     ax.tick_params(axis="y", labelsize=8, pad=2)  # Reduce font size and padding
    #
    #     # Ensure category labels are uppercase and wrap long names
    #     categories = cwe_counts_by_category.index
    #     ax.set_yticklabels([cat.replace(" ", "\n") if len(cat) > 15 else cat for cat in categories])
    #
    #     # Adjust the legend inside the plot in the lower right corner
    #     ax.legend(title="CWE TAGS", loc='lower right', fontsize=8, frameon=True)
    #
    #     # Adjust layout to prevent clipping
    #     plt.tight_layout()
    #
    #     # Remove extra margins
    #     plt.margins(0)
    #
    #     # Save the figure manually with bbox_inches="tight" before calling save_plot()
    #     plot_path = "cwe_distribution_by_category_stacked.pdf"
    #     fig.savefig(plot_path, bbox_inches="tight", pad_inches=0)
    #
    #     # Use save_plot without bbox_inches
    #     self.results_handler.save_plot(fig, plot_path)
    #
    #     print("Plot saved:", plot_path)






    def plot_vulnerability_proneness_comparison_bw(self, file_path_source, file_path_all):
        """
        Genera un boxplot en escala de grises con outliers filtrados mediante IQR,
        eliminando el fondo y moviendo la leyenda a la izquierda.
        """
        import matplotlib.pyplot as plt
        import seaborn as sns
        import pandas as pd
        import os
        import numpy as np

        # Configurar estilo de matplotlib en blanco y negro sin fondo
        plt.style.use('seaborn-v0_8-whitegrid')  # Mantiene los ejes visibles
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_all = pd.read_csv(file_path_all)

        # Asignar explícitamente la columna de Vulnerability-Proneness
        df_source["Vulnerability-Proneness"] = df_source["vulnerability-proneness-source"]
        df_all["Vulnerability-Proneness"] = df_all["vulnerability-proneness-all"]

        # Agregar etiquetas para distinguir datasets
        df_source["Data Source"] = "Source Only"
        df_all["Data Source"] = "Source + Dependencies"

        # Combinar ambos conjuntos de datos
        df_combined = pd.concat([
            df_source[["Category", "Vulnerability-Proneness", "Data Source"]],
            df_all[["Category", "Vulnerability-Proneness", "Data Source"]]
        ])

        # Aplicar eliminación de outliers usando IQR
        Q1 = df_combined["Vulnerability-Proneness"].quantile(0.25)
        Q3 = df_combined["Vulnerability-Proneness"].quantile(0.75)
        IQR = Q3 - Q1

        # Definir límites para eliminar outliers
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Filtrar datos dentro del rango IQR
        df_filtered = df_combined[(df_combined["Vulnerability-Proneness"] >= lower_bound) & 
                                (df_combined["Vulnerability-Proneness"] <= upper_bound)]

        # Contar el número de acciones por categoría y filtrar aquellas con al menos 10 acciones
        category_counts = df_filtered.groupby('Category').size()
        MIN_ACTIONS = 10
        categories_to_keep = category_counts[category_counts >= MIN_ACTIONS].index
        df_filtered = df_filtered[df_filtered['Category'].isin(categories_to_keep)]

        # Calcular la mediana por categoría y ordenar las categorías según esta
        category_medians = df_filtered.groupby('Category')['Vulnerability-Proneness'].median().sort_values()
        ordered_categories = category_medians.index
        df_filtered['Category'] = pd.Categorical(df_filtered['Category'], categories=ordered_categories, ordered=True)

        # Crear figura con tamaño optimizado y alta resolución
        fig, ax = plt.subplots(figsize=(15, 8), dpi=300)

        # Crear el boxplot en escala de grises sin fondo
        sns.boxplot(
            x="Category",
            y="Vulnerability-Proneness",
            hue="Data Source",
            data=df_filtered,
            palette=["#c0c0c0", "#808080"],  # Grises más suaves
            width=0.6,
            linewidth=1.2,
            fliersize=3,
            whis=[5, 95],  # Mantiene los bigotes dentro de un rango razonable
            ax=ax
        )

        # Ajustar etiquetas y título
        plt.xlabel("Category", fontweight='bold', labelpad=10)
        plt.ylabel("Vulnerability-Proneness", fontweight='bold', labelpad=10)
        plt.title("Comparison of Vulnerability-Proneness Across Categories (IQR Filtered, Grayscale)", 
                fontweight='bold', pad=20)

        # Mover la leyenda a la izquierda
        plt.legend(title="Data Source", title_fontsize=12, fontsize=10, loc='upper left', bbox_to_anchor=(0, 1))

        # Rotar etiquetas del eje x y ajustar layout
        plt.xticks(rotation=30, ha='right')
        plt.tight_layout()

        # Quitar solo el fondo pero mantener los ejes
        sns.despine()
        ax.set_facecolor('white')

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_proneness_comparison_bw_iqr_clean.pdf")
        print("Plot saved: vulnerability_proneness_comparison_bw_iqr_clean.pdf")
