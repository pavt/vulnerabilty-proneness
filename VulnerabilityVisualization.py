import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import ast
import squarify
import plotly.express as px
import networkx as nx
import scipy.cluster.hierarchy as sch
import community as community_louvain  
import itertools
from itertools import combinations
from collections import Counter

 

class VulnerabilityVisualization:
    def __init__(self, results_handler):
        self.results_handler = results_handler

    def plot_boxplot(self, df):
        """
        Generates and saves a boxplot of high and critical vulnerabilities by category.
        """
        fig, ax = plt.subplots(figsize=(12, 6))
        ax.boxplot(df['vulnerabilities_list'], labels=df['Category'], vert=True,
                   patch_artist=True, boxprops=dict(facecolor="white", color="black"),
                   medianprops=dict(color="orange"))
        plt.xticks(rotation=45, ha='right')
        plt.ylabel('Number of High and Critical Vulnerabilities')
        plt.title('High and Critical Vulnerabilities by Category')
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        self.results_handler.save_plot(fig, "boxplot_vulnerabilities.pdf")

    def plot_histogram(self, df):
        """
        Generates and saves a histogram of vulnerability-proneness.
        """
        sorted_vulnerabilities = [value for sublist in df['vulnerabilities_list'] for value in sublist]
        fig, ax = plt.subplots(figsize=(7, 5))
        ax.hist(sorted_vulnerabilities, bins=50, color='steelblue', edgecolor='black', alpha=0.8)
        plt.title("Sorted Vulnerability-Proneness Histogram")
        plt.xlabel("Vulnerability-Proneness")
        plt.ylabel("Frequency")
        plt.grid(True, linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "histogram_vulnerability_proneness.pdf")

    def plot_category_histograms(self, df):
        """
        Generates and saves probability histograms of vulnerability-proneness for each category.
        """ 
        categories = df['Category'].unique()
        num_categories = len(categories)

        fig, axes = plt.subplots(1, num_categories, figsize=(15, 4), sharex=True, sharey=True)
        colors = plt.cm.viridis(np.linspace(0, 1, num_categories))

        for ax, (category, color) in zip(axes, zip(categories, colors)):
            values = df[df['Category'] == category]['vulnerabilities_list'].iloc[0]
            max_value = max(values)  # Obtener el máximo valor para la categoría actual
            ax.hist(values, bins=20, color=color, alpha=0.7, edgecolor="black", density=True)
            ax.set_title(category, fontsize=10)
            ax.set_xlim(0, max_value + 2)  # Ajustar el límite del eje x al máximo de la categoría
            ax.set_ylim(0, 1)

        plt.suptitle("Probability Histogram of Vulnerability-Proneness by Category", y=1.05, fontsize=14)
        plt.tight_layout()
        self.results_handler.save_plot(fig, "category_histograms.pdf")




    def plot_scatter_vulnerability_vs_components(self, df):
        """
        Generates and saves a scatter plot showing the relationship between Number of Components and Vulnerability-Proneness.
        """
        # Add the required column
        df['Vulnerability-Proneness'] = df['High'] + df['Critical']

        fig, ax = plt.subplots(figsize=(10, 6))
        sns.scatterplot(data=df, x='Number of Components', y='Vulnerability-Proneness', hue='Category',
                        alpha=0.7, edgecolor='black', ax=ax)
        sns.regplot(data=df, x='Number of Components', y='Vulnerability-Proneness', scatter=False,
                    color='red', ci=None, ax=ax)
        ax.set_xscale('log')
        ax.set_yscale('log')
        ax.set_xlabel("Number of Components")
        ax.set_ylabel("Vulnerability-Proneness (High + Critical)")
        ax.set_title("Relationship Between Number of Components and Vulnerability-Proneness (Log Scale)")
        ax.grid(True, linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "scatter_vulnerability_vs_components.pdf")

    def plot_cwe_distribution(self, df):
        """
        Generates and saves a bar plot of the top 15 most common CWE tags.
        """
        cwe_counts = Counter(tag for tags in df['CWE Tags'] for tag in tags)
        cwe_df = pd.DataFrame(cwe_counts.items(), columns=['CWE Tag', 'Frequency']).sort_values(by='Frequency', ascending=False)

        fig, ax = plt.subplots(figsize=(12, 6))
        sns.barplot(data=cwe_df.head(15), x='Frequency', y='CWE Tag', palette='coolwarm', ax=ax)
        ax.set_xlabel("Frequency")
        ax.set_ylabel("CWE Tag")
        ax.set_title("Top 15 Most Common CWE Tags Across Categories")
        ax.grid(axis='x', linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "cwe_distribution.pdf")


    def process_cwe_tags(self, cwe_value, *args):

        # Si ya es una lista, no se modifica
        if isinstance(cwe_value, list):
            return cwe_value
        # Si es una cadena que parece una lista, intenta evaluarla
        elif isinstance(cwe_value, str) and cwe_value.startswith('[') and cwe_value.endswith(']'):
            try:
                return ast.literal_eval(cwe_value)
            except (ValueError, SyntaxError):
                # Si la evaluación falla, retorna una lista vacía o None
                return []
        # Para valores NaN o cualquier otro formato no esperado, retorna lista vacía
        else:
            return []

    def plot_cwe_distribution_by_category(self, df):
        """
        Genera un mapa de burbujas mostrando la relación entre categorías y CWEs.
        """
        # Asegurarse de que 'CWE Tags' está en formato lista de strings
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Crear un DataFrame plano con cada CWE y su categoría asociada
        exploded_df = df.explode('CWE Tags')
        cwe_category_counts = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Obtener el total de acciones por categoría
        category_totals = df['Category'].value_counts().reset_index()
        category_totals.columns = ['Category', 'TotalActions']

        # Combinar el total de acciones con las frecuencias de CWE por categoría
        cwe_category_counts = cwe_category_counts.merge(category_totals, on='Category')

        # Normalizar la columna 'Count' dividiendo por el total de acciones
        cwe_category_counts['NormalizedCount'] = cwe_category_counts['Count'] / cwe_category_counts['TotalActions']

        # Crear el gráfico de burbujas con los valores normalizados
        fig, ax = plt.subplots(figsize=(12, 8))
        scatter = ax.scatter(
            x=cwe_category_counts['Category'],
            y=cwe_category_counts['CWE Tags'],
            s=cwe_category_counts['NormalizedCount'] * 1000,  # Tamaño proporcional a la frecuencia normalizada
            alpha=0.6,
            edgecolors='w',
            linewidth=0.5
        )

        # Configurar ejes y títulos
        ax.set_title('Distribución Normalizada de CWEs por Categoría (Mapa de Burbujas)', fontsize=14)
        ax.set_xlabel('Categoría', fontsize=12)
        ax.set_ylabel('CWE', fontsize=12)
        ax.grid(True, linestyle='--', alpha=0.5)
        plt.xticks(rotation=45, ha='right')

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "cwe_bubble_map_by_category_normalized.pdf")



    def plot_cwe_distribution_by_frequency(self, df, min_frequency=5):
        """
        Generates a horizontal bar chart showing the frequency distribution of CWEs in the dataset.
        """
        # Normalize 'CWE Tags' to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode the DataFrame to work with individual CWEs
        exploded_df = df.explode('CWE Tags')

        # Count the frequency of each CWE
        cwe_counts = exploded_df['CWE Tags'].value_counts().reset_index()
        cwe_counts.columns = ['CWE', 'Count']

        # Filter out low-frequency CWEs for better visualization
        cwe_counts = cwe_counts[cwe_counts['Count'] >= min_frequency]

        # Create the horizontal bar chart
        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(
            data=cwe_counts, 
            x='Count', 
            y='CWE', 
            palette='coolwarm', 
            ax=ax
        )

        # Configure axes and titles
        ax.set_title('CWE Distribution by Frequency (Bar Chart)', fontsize=14)
        ax.set_xlabel('Occurrence Count', fontsize=12)
        ax.set_ylabel('CWE', fontsize=12)
        ax.grid(axis='x', linestyle='--', alpha=0.5)

        # Save the plot
        self.results_handler.save_plot(fig, "cwe_bar_chart_by_frequency.pdf")




    def plot_cwe_distribution_violinplot(self, df, min_frequency=1):
        """
        Generates a violin plot showing the distribution of CWE occurrences across different categories.
        """
        # Normalize 'CWE Tags' to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode the DataFrame to work with individual CWEs
        exploded_df = df.explode('CWE Tags')

        # Count occurrences of each CWE within each category
        cwe_category_counts = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Filter out low-frequency CWEs for better visualization
        cwe_category_counts = cwe_category_counts[cwe_category_counts['Count'] >= min_frequency]

        # Create the violin plot
        fig, ax = plt.subplots(figsize=(14, 8))
        sns.violinplot(
            data=cwe_category_counts, 
            x='Category', 
            y='Count', 
            scale='width', 
            inner='quartile', 
            palette='coolwarm', 
            ax=ax
        )

        # Configure axes and titles
        ax.set_title('CWE Distribution by Category (Violin Plot)', fontsize=14)
        ax.set_xlabel('Category', fontsize=12)
        ax.set_ylabel('CWE Occurrence Count', fontsize=12)
        ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')
        ax.grid(axis='y', linestyle='--', alpha=0.5)

        # Save the plot
        self.results_handler.save_plot(fig, "cwe_violin_plot_by_category.pdf")




    def plot_vulnerability_distribution(self, df):
        """
        Generates histograms and density plots showing the frequency of vulnerabilities per category.
        This visualization helps analyze the prevalence of vulnerabilities across different action categories.
        """
        # Convert 'Total Vulnerabilities' to numeric if not already
        df['Total Vulnerabilities'] = pd.to_numeric(df['Total Vulnerabilities'], errors='coerce')

        # Set up the figure with subplots for histogram and density plot
        fig, axes = plt.subplots(1, 2, figsize=(14, 6), sharex=False)

        # Histogram of total vulnerabilities per category
        sns.histplot(data=df, x='Total Vulnerabilities', hue='Category', bins=30, kde=False, ax=axes[0], multiple="stack")
        axes[0].set_title("Histogram of Total Vulnerabilities per Category")
        axes[0].set_xlabel("Total Vulnerabilities")
        axes[0].set_ylabel("Frequency")
        axes[0].grid(axis='y', linestyle='--', alpha=0.5)

        # Density plot (Kernel Density Estimation) to see the smooth distribution
        sns.kdeplot(data=df, x='Total Vulnerabilities', hue='Category', fill=True, common_norm=False, alpha=0.5, ax=axes[1])
        axes[1].set_title("Density Plot of Vulnerabilities per Category")
        axes[1].set_xlabel("Total Vulnerabilities")
        axes[1].set_ylabel("Density")
        axes[1].grid(axis='y', linestyle='--', alpha=0.5)

        # Adjust layout and save the plot
        plt.tight_layout()
        self.results_handler.save_plot(fig, "vulnerability_distribution_hist_density.pdf")




    def plot_vulnerability_bubble_scatter(self, df):
        """
        Generates a Bubble Map and a Scatter Plot to visualize relationships between categories and vulnerabilities.
        - Bubble Map: Shows normalized vulnerabilities across categories.
        - Scatter Plot: Examines relationships between two vulnerability-related attributes (e.g., Total Vulnerabilities vs. Number of Components).
        """

        # Normalize total vulnerabilities for better scaling in bubble size
        df['Total Vulnerabilities'] = pd.to_numeric(df['Total Vulnerabilities'], errors='coerce')
        df['Normalized Vulnerabilities'] = df.groupby('Category')['Total Vulnerabilities'].transform(lambda x: x / x.max())

        # Set up the figure with subplots
        fig, axes = plt.subplots(1, 2, figsize=(14, 6))

        # ---- Bubble Map (Improved) ----
        bubble_df = df.groupby("Category", as_index=False).agg(
            {"Total Vulnerabilities": "sum", "Number of Components": "mean"}
        )
        bubble_df['Bubble Size'] = bubble_df["Total Vulnerabilities"] / bubble_df["Total Vulnerabilities"].max() * 1000  # Scale size

        sns.scatterplot(
            data=bubble_df,
            x="Category",
            y="Total Vulnerabilities",
            size="Bubble Size",
            sizes=(10, 1000),
            alpha=0.6,
            ax=axes[0]
        )
        axes[0].set_xticklabels(axes[0].get_xticklabels(), rotation=45, ha="right")
        axes[0].set_title("Bubble Map: Normalized Vulnerabilities by Category")
        axes[0].set_xlabel("Category")
        axes[0].set_ylabel("Total Vulnerabilities")
        axes[0].grid(True, linestyle="--", alpha=0.5)

        # ---- Scatter Plot ----
        sns.scatterplot(
            data=df,
            x="Number of Components",
            y="Total Vulnerabilities",
            hue="Category",
            size="Total Vulnerabilities",
            sizes=(10, 300),
            alpha=0.6,
            ax=axes[1]
        )
        axes[1].set_xscale("log")  # Log scale for better visibility if needed
        axes[1].set_yscale("log")
        axes[1].set_title("Scatter Plot: Components vs. Vulnerabilities")
        axes[1].set_xlabel("Number of Components (Log Scale)")
        axes[1].set_ylabel("Total Vulnerabilities (Log Scale)")
        axes[1].grid(True, linestyle="--", alpha=0.5)

        # Adjust layout and save the plot
        plt.tight_layout()
        self.results_handler.save_plot(fig, "vulnerability_bubble_scatter.pdf")



    def plot_cwe_category_heatmap(self, df):
        """
        Generates a heatmap to visualize the intensity of CWEs per category.
        
        - The x-axis represents different vulnerability categories.
        - The y-axis represents CWE tags (types of vulnerabilities).
        - Color intensity indicates the frequency of each CWE in a given category.
        - Categories are sorted left-to-right based on total CWE occurrences.
        - Handles long category names without modifying words.
        """

        import pandas as pd
        import matplotlib.pyplot as plt
        import seaborn as sns

        # Ensure 'CWE Tags' is parsed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Create a pivot table counting CWEs per category
        heatmap_data = exploded_df.groupby(['CWE Tags', 'Category']).size().unstack(fill_value=0)

        # Ordenar las columnas (categorías) de izquierda a derecha según la suma total de ocurrencias de CWE
        category_order = heatmap_data.sum(axis=0).sort_values(ascending=True).index  # Orden ascendente
        heatmap_data = heatmap_data[category_order]  # Reordenar matriz

        # Normalize each row by its maximum value for better comparability
        heatmap_data = heatmap_data.div(heatmap_data.max(axis=1), axis=0)

        # Crear el heatmap con columnas ordenadas
        fig, ax = plt.subplots(figsize=(12, 9))
        sns.heatmap(heatmap_data, cmap="Blues", cbar=True, ax=ax)  # Barra de color en su posición original

        # Formato del gráfico
        ax.set_title("Frequency of CWEs per Category", fontsize=14, pad=15)
        ax.set_xlabel("")
        ax.set_ylabel("")  # Se elimina el label del eje Y

        # Estrategia para nombres largos:
        category_labels = [label.replace(" ", "\n") if len(label) > 15 else label for label in category_order]
        ax.set_xticklabels(category_labels, fontsize=10)  # Reduce la fuente y permite saltos de línea en nombres largos

        # Rotar las etiquetas para evitar superposición
        plt.xticks(rotation=45, ha='right')

        # Ajustar márgenes automáticamente para evitar cortes
        plt.tight_layout()

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "cwe_category_heatmap.pdf")
        print("Plot saved: cwe_category_heatmap.pdf")








    def plot_cwe_category_treemap(self, df):
        """
        Generates a treemap to visualize the hierarchical distribution of CWEs within categories.

        - Each category is represented as a large rectangle.
        - Each CWE within a category is a sub-rectangle.
        - The size of each rectangle represents the frequency of occurrences.
        """

        # Ensure 'CWE Tags' is processed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Count CWEs per category
        treemap_data = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Create a treemap
        fig = px.treemap(treemap_data, 
                        path=['Category', 'CWE Tags'], 
                        values='Count', 
                        color='Count',
                        color_continuous_scale='Blues',
                        title="Treemap: Hierarchical Distribution of CWEs within Categories")

        # Save the plot
        fig.write_image(f"{self.results_handler.results_path}/cwe_category_treemap.pdf")
        print("Treemap saved: cwe_category_treemap.pdf")


    def plot_cwe_category_sunburst(self, df):
        """
        Generates a sunburst chart to visualize the hierarchical structure of CWEs within categories.

        - The inner circle represents categories.
        - The outer circles represent CWEs under those categories.
        - The size of each slice represents the frequency of occurrences.
        """

        # Ensure 'CWE Tags' is processed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Count CWEs per category
        sunburst_data = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Create a sunburst chart
        fig = px.sunburst(sunburst_data, 
                        path=['Category', 'CWE Tags'], 
                        values='Count', 
                        color='Count',
                        color_continuous_scale='Blues',
                        title="Sunburst Chart: CWE Hierarchy within Categories")

        # Save the plot
        fig.write_image(f"{self.results_handler.results_path}/cwe_category_sunburst.pdf")
        print("Sunburst Chart saved: cwe_category_sunburst.pdf")


    def plot_cwe_cooccurrence_matrix(self, df, min_occurrences=10):
        """
        Generates a co-occurrence matrix for CWEs, filtering only the most frequent ones.
        """
        import seaborn as sns
        import numpy as np
        import pandas as pd
        from itertools import combinations
        import matplotlib.pyplot as plt
        
        # Convert CWE Tags column to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)
        
        # Explode CWE Tags to count frequency of each CWE
        all_cwes = df.explode('CWE Tags')['CWE Tags']
        cwe_counts = all_cwes.value_counts()
        
        # Filter CWEs that appear at least 'min_occurrences' times
        frequent_cwes = list(cwe_counts[cwe_counts >= min_occurrences].index)  # Convert to list
        
        # Extract CWE pairs from filtered rows
        cwe_pairs = []
        for cwes in df['CWE Tags']:
            filtered_cwes = [cwe for cwe in cwes if cwe in frequent_cwes]
            cwe_pairs.extend(combinations(filtered_cwes, 2))
        
        # Build co-occurrence matrix
        cwe_cooccurrence = pd.DataFrame(0, index=frequent_cwes, columns=frequent_cwes)
        for cwe1, cwe2 in cwe_pairs:
            cwe_cooccurrence.at[cwe1, cwe2] += 1
            cwe_cooccurrence.at[cwe2, cwe1] += 1  # Symmetric matrix
        
        # Create heatmap figure
        fig, ax = plt.subplots(figsize=(12, 10))  # Ensure 'fig' is properly assigned
        sns.heatmap(cwe_cooccurrence, cmap='Blues', annot=False, linewidths=0.5, ax=ax)
        ax.set_title('CWE Co-Occurrence Matrix (Filtered)')
        plt.xticks(rotation=45, ha='right')
        plt.yticks(rotation=0)
        
        # Save plot using 'fig' instead of 'plt'
        self.results_handler.save_plot(fig, "cwe_cooccurrence_matrix_filtered.pdf")

 

    def plot_vulnerability_proneness_comparison(self, file_path_source, file_path_all):
        """
        Genera un boxplot comparando la Vulnerability-Proneness entre código fuente y dependencias.
        Solo se incluyen categorías con al menos 3 acciones, ordenadas por la mediana.
        Se añaden impresiones de estadísticas descriptivas para diagnosticar diferencias.
        """
        import matplotlib.pyplot as plt
        import seaborn as sns
        import pandas as pd
        import os

        # Configurar estilo y parámetros de matplotlib
        plt.style.use('seaborn-v0_8-darkgrid')
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_all = pd.read_csv(file_path_all)
        
        # Imprimir estadísticas descriptivas para diagnosticar diferencias
        print("Estadísticas para Source Only:")
        print(df_source["vulnerability-proneness-source"].describe())
        print("\nEstadísticas para Source + Dependencies:")
        print(df_all["vulnerability-proneness-all"].describe())
        
        # Asignar explícitamente la columna de Vulnerability-Proneness a partir de la columna original de cada archivo
        # Así, el CSV de código fuente usa "vulnerability-proneness-source" y el CSV de dependencias "vulnerability-proneness-all"
        df_source["Vulnerability-Proneness"] = df_source["vulnerability-proneness-source"]
        df_all["Vulnerability-Proneness"] = df_all["vulnerability-proneness-all"]
        
        # Agregar etiquetas para distinguir datasets
        df_source["Data Source"] = "Source Only"
        df_all["Data Source"] = "Source + Dependencies"
        
        # Combinar ambos conjuntos de datos
        df_combined = pd.concat([
            df_source[["Category", "Vulnerability-Proneness", "Data Source"]],
            df_all[["Category", "Vulnerability-Proneness", "Data Source"]]
        ])
        
        # Contar el número de acciones por categoría y filtrar aquellas con al menos 3 acciones
        category_counts = df_combined.groupby('Category').size()
        MIN_ACTIONS = 10
        categories_to_keep = category_counts[category_counts >= MIN_ACTIONS].index
        df_filtered = df_combined[df_combined['Category'].isin(categories_to_keep)]
        
        # Calcular la mediana por categoría y ordenar las categorías según ésta
        category_medians = df_filtered.groupby('Category')['Vulnerability-Proneness'].median().sort_values()
        ordered_categories = category_medians.index
        df_filtered['Category'] = pd.Categorical(df_filtered['Category'], categories=ordered_categories, ordered=True)
        
        # Crear figura con tamaño optimizado y alta resolución
        fig, ax = plt.subplots(figsize=(15, 8), dpi=300)
        
        # Crear el boxplot con mejoras visuales
        sns.boxplot(
            x="Category",
            y="Vulnerability-Proneness",
            hue="Data Source",
            data=df_filtered,
            palette=["#2E86C1", "#E74C3C"],
            width=0.7,
            fliersize=4,
            ax=ax
        )
        
        # Personalizar etiquetas y título
        plt.xlabel("", fontweight='bold', labelpad=10)
        plt.ylabel("Vulnerability-Proneness", fontweight='bold', labelpad=10)
        plt.title("Comparison of Vulnerability-Proneness Across Categories\n(Categories with ≥10 actions, sorted by median)", 
                fontweight='bold', pad=20)
        
        # Personalizar la leyenda
        plt.legend(
            title="Data Source",
            title_fontsize=12,
            fontsize=10,
            loc='upper left',
            framealpha=0.9,
            edgecolor='gray'
        )
        
        # Rotar etiquetas del eje x y ajustar layout
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        
        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_proneness_comparison.pdf")
        print("Plot saved: vulnerability_proneness_comparison.pdf")

    def plot_vulnerability_components_relationship_logscale(self, file_path_source, file_path_all):
        """
        Genera un scatter plot comparando el número de componentes y el incremento en 
        Vulnerability-Proneness (diferencia entre 'vulnerability-proneness-all' y 'vulnerability-proneness-source'),
        aplicando escala logarítmica en ambos ejes. Solo se incluyen categorías con al menos 3 repositorios.
        """

        # Configurar el estilo de matplotlib
        plt.style.use('seaborn-v0_8-darkgrid')
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_aggregated = pd.read_csv(file_path_all)

        # Preparar los datos: seleccionar las columnas relevantes
        df_source = df_source[['repo_owner', 'repo_name', 'Category', 'vulnerability-proneness-source']]
        df_aggregated = df_aggregated[['repo_owner', 'repo_name', 'Category', 'Number of Components', 'vulnerability-proneness-all']]

        # Merge de ambos conjuntos de datos basado en repositorio y categoría
        df_merged = pd.merge(df_source, df_aggregated, on=['repo_owner', 'repo_name', 'Category'], how="inner")

        # Calcular el incremento de vulnerabilidad: diferencia entre aggregated y source
        df_merged['vulnerability_increase'] = df_merged['vulnerability-proneness-all'] - df_merged['vulnerability-proneness-source']

        # Filtrar categorías con al menos MIN_REPOS repositorios
        category_counts = df_merged['Category'].value_counts()
        MIN_REPOS = 3
        categories_to_keep = category_counts[category_counts >= MIN_REPOS].index
        df_filtered = df_merged[df_merged['Category'].isin(categories_to_keep)]

        # Crear figura con alta resolución
        fig, ax = plt.subplots(figsize=(12, 8), dpi=300)

        # Crear el scatter plot
        scatter = sns.scatterplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            hue="Category",
            palette="deep",
            alpha=0.7,
            s=100,            # Tamaño de los puntos
            edgecolor='white',  # Borde blanco para los puntos
            linewidth=0.5,
            ax=ax
        )

        # Agregar línea de tendencia
        sns.regplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            scatter=False,
            color="#E74C3C",
            line_kws={
                "linewidth": 2,
                "linestyle": "--",
                "alpha": 0.8
            },
            ax=ax
        )

        # Aplicar escala logarítmica a ambos ejes
        ax.set_xscale('log')
        ax.set_yscale('log')

        # Personalizar etiquetas y título
        plt.xlabel("Number of Components (log scale)", fontweight='bold', labelpad=10)
        plt.ylabel("Increase in Vulnerability-Proneness (log scale)", fontweight='bold', labelpad=10)
        plt.title("Component Count vs. Vulnerability-Proneness Increase\n(Scaled Logarithmically)", 
                fontweight='bold', pad=20)

        # Personalizar la leyenda
        legend = plt.legend(
            title="Category",
            title_fontsize=12,
            fontsize=10,
            loc='center left',
            bbox_to_anchor=(1, 0.5),
            frameon=True,
            framealpha=0.9,
            edgecolor='gray'
        )

        # Agregar grid mejorado
        plt.grid(True, linestyle='--', alpha=0.3, color='gray')
        plt.margins(x=0.02)

        # Calcular y mostrar la correlación en escala logarítmica
        # Se utiliza log para ambas variables; si hay ceros o valores negativos, se debe filtrar.
        # Suponemos que Number of Components y vulnerability_increase son positivos.
        correlation = np.corrcoef(np.log(df_filtered["Number of Components"]), np.log(df_filtered["vulnerability_increase"]))[0, 1]
        plt.text(0.02, 0.98, f'Correlation (log): {correlation:.2f}', 
                transform=ax.transAxes, 
                fontsize=10,
                bbox=dict(facecolor='white', edgecolor='gray', alpha=0.8))

        plt.tight_layout()

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_components_relationship_logscale.pdf")
        print("Plot saved: vulnerability_components_relationship_logscale.pdf")

    def plot_vulnerability_components_relationship_logscale(self, file_path_source, file_path_all):
        """
        Genera un scatter plot comparando el número de componentes y el incremento en 
        Vulnerability-Proneness (diferencia entre 'vulnerability-proneness-all' y 'vulnerability-proneness-source'),
        aplicando escala logarítmica en ambos ejes. Solo se incluyen categorías con al menos 3 repositorios.
        """
        import pandas as pd
        import matplotlib.pyplot as plt
        import seaborn as sns
        import numpy as np
        import os

        # Configurar el estilo de matplotlib
        plt.style.use('seaborn-v0_8-darkgrid')
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_aggregated = pd.read_csv(file_path_all)

        # Preparar los datos: seleccionar las columnas relevantes
        df_source = df_source[['repo_owner', 'repo_name', 'Category', 'vulnerability-proneness-source']]
        df_aggregated = df_aggregated[['repo_owner', 'repo_name', 'Category', 'Number of Components', 'vulnerability-proneness-all']]

        # Merge de ambos conjuntos de datos basado en repositorio y categoría
        df_merged = pd.merge(df_source, df_aggregated, on=['repo_owner', 'repo_name', 'Category'], how="inner")

        # Calcular el incremento de vulnerabilidad: diferencia entre aggregated y source
        df_merged['vulnerability_increase'] = df_merged['vulnerability-proneness-all'] - df_merged['vulnerability-proneness-source']

        # Filtrar categorías con al menos MIN_REPOS repositorios
        category_counts = df_merged['Category'].value_counts()
        MIN_REPOS = 3
        categories_to_keep = category_counts[category_counts >= MIN_REPOS].index
        df_filtered = df_merged[df_merged['Category'].isin(categories_to_keep)]

        # Crear figura con alta resolución
        fig, ax = plt.subplots(figsize=(12, 8), dpi=300)

        # Crear el scatter plot
        scatter = sns.scatterplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            hue="Category",
            palette="deep",
            alpha=0.7,
            s=100,            # Tamaño de los puntos
            edgecolor='white',  # Borde blanco para los puntos
            linewidth=0.5,
            ax=ax
        )

        # Agregar línea de tendencia
        sns.regplot(
            data=df_filtered,
            x="Number of Components",
            y="vulnerability_increase",
            scatter=False,
            color="#E74C3C",
            line_kws={
                "linewidth": 2,
                "linestyle": "--",
                "alpha": 0.8
            },
            ax=ax
        )

        # Aplicar escala logarítmica a ambos ejes
        ax.set_xscale('log')
        ax.set_yscale('log')

        # Personalizar etiquetas y título
        plt.xlabel("Number of Components (log scale)", fontweight='bold', labelpad=10)
        plt.ylabel("Increase in Vulnerability-Proneness (log scale)", fontweight='bold', labelpad=10)
        plt.title("Component Count vs. Vulnerability-Proneness Increase\n(Scaled Logarithmically)", 
                fontweight='bold', pad=20)

        # Personalizar la leyenda
        legend = plt.legend(
            title="Category",
            title_fontsize=12,
            fontsize=10,
            loc='center left',
            bbox_to_anchor=(1, 0.5),
            frameon=True,
            framealpha=0.9,
            edgecolor='gray'
        )

        # Agregar grid mejorado y ajustar márgenes
        plt.grid(True, linestyle='--', alpha=0.3, color='gray')
        plt.margins(x=0.02)

        # Calcular y mostrar la correlación en escala logarítmica
        # Se calcula la correlación entre los logaritmos de los valores (suponiendo que ambos sean positivos)
        correlation = np.corrcoef(np.log(df_filtered["Number of Components"]), np.log(df_filtered["vulnerability_increase"]))[0, 1]
        plt.text(0.02, 0.98, f'Correlation (log): {correlation:.2f}', 
                transform=ax.transAxes, 
                fontsize=10,
                bbox=dict(facecolor='white', edgecolor='gray', alpha=0.8))

        plt.tight_layout()

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_components_relationship_logscale.pdf")
        print("Plot saved: vulnerability_components_relationship_logscale.pdf")

    def plot_cwe_distribution_by_category_stacked(self, file_path, figsize=(6, 5)):
        """
        Genera un stacked bar chart que muestra la distribución de las 10 CWEs críticas
        agrupadas por categoría, utilizando el archivo indicado.
        Las categorías se ordenan de forma ascendente según la suma total de las CWEs críticas.
        Se filtran las categorías que tengan menos de 5 ocurrencias en total.

        Parámetros:
        - file_path: Ruta del archivo CSV con los datos.
        - figsize: Tamaño del gráfico (ancho, alto), por defecto (10, 6).
        """
        import pandas as pd
        import matplotlib.pyplot as plt

        # Cargar el archivo CSV con los datos de vulnerabilidades agregadas
        df = pd.read_csv(file_path)

        # Expandir la columna de 'CWE Tags': convertir la cadena en lista de CWEs
        df['CWE Tags'] = df['CWE Tags'].apply(eval)

        # Definir las 10 CWEs más críticas por su severidad
        critical_cwes = ['cwe-020', 'CWE-200', 'CWE-287', 'CWE-352', 'CWE-74', 
                        'CWE-1333', 'CWE-915', 'CWE-78', 'CWE-400', 'CWE-259']

        # Crear una columna para cada CWE de interés, contando las ocurrencias
        for cwe in critical_cwes:
            df[cwe] = df['CWE Tags'].apply(lambda x: x.count(cwe))

        # Agrupar por categoría y sumar las ocurrencias de cada CWE crítica
        cwe_counts_by_category = df.groupby('Category')[critical_cwes].sum()

        # Filtrar para incluir solo categorías con al menos 5 ocurrencias totales de CWEs
        cwe_counts_by_category = cwe_counts_by_category[
            (cwe_counts_by_category.sum(axis=1) >= 5)
        ]

        # Ordenar las categorías de forma ascendente según la suma total de las ocurrencias
        total_counts = cwe_counts_by_category.sum(axis=1)
        ordered_categories = total_counts.sort_values(ascending=True).index
        cwe_counts_by_category = cwe_counts_by_category.loc[ordered_categories]

        # Crear la figura con tamaño ajustable
        fig, ax = plt.subplots(figsize=figsize)  # <-- Permite ajustar tamaño del gráfico

        # Graficar el stacked bar chart
        cwe_counts_by_category.plot(kind='barh', stacked=True, ax=ax)

        # Ajustar título y etiquetas
        ax.set_title("Top 10 CWE Across Categories (Critical)", fontsize=10, pad=15)
        ax.set_xlabel("CWE Count", fontsize=8)
        ax.set_ylabel("")  # <-- Se elimina la etiqueta del eje Y

        # Ajustar tamaño de fuente y espaciado en etiquetas
        ax.tick_params(axis="y", labelsize=8, pad=2)  # Reduce el tamaño de las etiquetas y el espacio entre ellas

        # Dividir nombres largos en varias líneas si es necesario
        categories = cwe_counts_by_category.index
        ax.set_yticklabels([cat.replace(" ", "\n") if len(cat) > 15 else cat for cat in categories])

        # Ajustar la leyenda dentro del gráfico en la esquina inferior derecha
        ax.legend(title="CWE Tags", loc='lower right', fontsize=8, frameon=True)

        # Ajustar el layout para evitar cortes
        plt.tight_layout()

        # Guardar la figura
        self.results_handler.save_plot(fig, "cwe_distribution_by_category_stacked.pdf")
        print("Plot saved: cwe_distribution_by_category_stacked.pdf")





    def plot_vulnerability_proneness_comparison_bw(self, file_path_source, file_path_all):
        """
        Genera un boxplot en escala de grises con outliers filtrados mediante IQR,
        eliminando el fondo y moviendo la leyenda a la izquierda.
        """
        import matplotlib.pyplot as plt
        import seaborn as sns
        import pandas as pd
        import os
        import numpy as np

        # Configurar estilo de matplotlib en blanco y negro sin fondo
        plt.style.use('seaborn-v0_8-whitegrid')  # Mantiene los ejes visibles
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_all = pd.read_csv(file_path_all)

        # Asignar explícitamente la columna de Vulnerability-Proneness
        df_source["Vulnerability-Proneness"] = df_source["vulnerability-proneness-source"]
        df_all["Vulnerability-Proneness"] = df_all["vulnerability-proneness-all"]

        # Agregar etiquetas para distinguir datasets
        df_source["Data Source"] = "Source Only"
        df_all["Data Source"] = "Source + Dependencies"

        # Combinar ambos conjuntos de datos
        df_combined = pd.concat([
            df_source[["Category", "Vulnerability-Proneness", "Data Source"]],
            df_all[["Category", "Vulnerability-Proneness", "Data Source"]]
        ])

        # Aplicar eliminación de outliers usando IQR
        Q1 = df_combined["Vulnerability-Proneness"].quantile(0.25)
        Q3 = df_combined["Vulnerability-Proneness"].quantile(0.75)
        IQR = Q3 - Q1

        # Definir límites para eliminar outliers
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Filtrar datos dentro del rango IQR
        df_filtered = df_combined[(df_combined["Vulnerability-Proneness"] >= lower_bound) & 
                                (df_combined["Vulnerability-Proneness"] <= upper_bound)]

        # Contar el número de acciones por categoría y filtrar aquellas con al menos 10 acciones
        category_counts = df_filtered.groupby('Category').size()
        MIN_ACTIONS = 10
        categories_to_keep = category_counts[category_counts >= MIN_ACTIONS].index
        df_filtered = df_filtered[df_filtered['Category'].isin(categories_to_keep)]

        # Calcular la mediana por categoría y ordenar las categorías según esta
        category_medians = df_filtered.groupby('Category')['Vulnerability-Proneness'].median().sort_values()
        ordered_categories = category_medians.index
        df_filtered['Category'] = pd.Categorical(df_filtered['Category'], categories=ordered_categories, ordered=True)

        # Crear figura con tamaño optimizado y alta resolución
        fig, ax = plt.subplots(figsize=(15, 8), dpi=300)

        # Crear el boxplot en escala de grises sin fondo
        sns.boxplot(
            x="Category",
            y="Vulnerability-Proneness",
            hue="Data Source",
            data=df_filtered,
            palette=["#c0c0c0", "#808080"],  # Grises más suaves
            width=0.6,
            linewidth=1.2,
            fliersize=3,
            whis=[5, 95],  # Mantiene los bigotes dentro de un rango razonable
            ax=ax
        )

        # Ajustar etiquetas y título
        plt.xlabel("Category", fontweight='bold', labelpad=10)
        plt.ylabel("Vulnerability-Proneness", fontweight='bold', labelpad=10)
        plt.title("Comparison of Vulnerability-Proneness Across Categories (IQR Filtered, Grayscale)", 
                fontweight='bold', pad=20)

        # Mover la leyenda a la izquierda
        plt.legend(title="Data Source", title_fontsize=12, fontsize=10, loc='upper left', bbox_to_anchor=(0, 1))

        # Rotar etiquetas del eje x y ajustar layout
        plt.xticks(rotation=30, ha='right')
        plt.tight_layout()

        # Quitar solo el fondo pero mantener los ejes
        sns.despine()
        ax.set_facecolor('white')

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_proneness_comparison_bw_iqr_clean.pdf")
        print("Plot saved: vulnerability_proneness_comparison_bw_iqr_clean.pdf")
