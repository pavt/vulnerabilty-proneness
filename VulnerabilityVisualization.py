import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import ast
import squarify
import plotly.express as px
import networkx as nx
import scipy.cluster.hierarchy as sch
import community as community_louvain  
import itertools
from itertools import combinations
from collections import Counter

 

class VulnerabilityVisualization:
    def __init__(self, results_handler):
        self.results_handler = results_handler

    def plot_boxplot(self, df):
        """
        Generates and saves a boxplot of high and critical vulnerabilities by category.
        """
        fig, ax = plt.subplots(figsize=(12, 6))
        ax.boxplot(df['vulnerabilities_list'], labels=df['Category'], vert=True,
                   patch_artist=True, boxprops=dict(facecolor="white", color="black"),
                   medianprops=dict(color="orange"))
        plt.xticks(rotation=45, ha='right')
        plt.ylabel('Number of High and Critical Vulnerabilities')
        plt.title('High and Critical Vulnerabilities by Category')
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        self.results_handler.save_plot(fig, "boxplot_vulnerabilities.pdf")

    def plot_histogram(self, df):
        """
        Generates and saves a histogram of vulnerability-proneness.
        """
        sorted_vulnerabilities = [value for sublist in df['vulnerabilities_list'] for value in sublist]
        fig, ax = plt.subplots(figsize=(7, 5))
        ax.hist(sorted_vulnerabilities, bins=50, color='steelblue', edgecolor='black', alpha=0.8)
        plt.title("Sorted Vulnerability-Proneness Histogram")
        plt.xlabel("Vulnerability-Proneness")
        plt.ylabel("Frequency")
        plt.grid(True, linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "histogram_vulnerability_proneness.pdf")

    def plot_category_histograms(self, df):
        """
        Generates and saves probability histograms of vulnerability-proneness for each category.
        """
        categories = df['Category'].unique()
        num_categories = len(categories)

        fig, axes = plt.subplots(1, num_categories, figsize=(15, 4), sharex=True, sharey=True)
        colors = plt.cm.viridis(np.linspace(0, 1, num_categories))

        for ax, (category, color) in zip(axes, zip(categories, colors)):
            values = df[df['Category'] == category]['vulnerabilities_list'].iloc[0]
            max_value = max(values)  # Obtener el máximo valor para la categoría actual
            ax.hist(values, bins=20, color=color, alpha=0.7, edgecolor="black", density=True)
            ax.set_title(category, fontsize=10)
            ax.set_xlim(0, max_value + 2)  # Ajustar el límite del eje x al máximo de la categoría
            ax.set_ylim(0, 1)

        plt.suptitle("Probability Histogram of Vulnerability-Proneness by Category", y=1.05, fontsize=14)
        plt.tight_layout()
        self.results_handler.save_plot(fig, "category_histograms.pdf")




    def plot_scatter_vulnerability_vs_components(self, df):
        """
        Generates and saves a scatter plot showing the relationship between Number of Components and Vulnerability-Proneness.
        """
        # Add the required column
        df['Vulnerability-Proneness'] = df['High'] + df['Critical']

        fig, ax = plt.subplots(figsize=(10, 6))
        sns.scatterplot(data=df, x='Number of Components', y='Vulnerability-Proneness', hue='Category',
                        alpha=0.7, edgecolor='black', ax=ax)
        sns.regplot(data=df, x='Number of Components', y='Vulnerability-Proneness', scatter=False,
                    color='red', ci=None, ax=ax)
        ax.set_xscale('log')
        ax.set_yscale('log')
        ax.set_xlabel("Number of Components")
        ax.set_ylabel("Vulnerability-Proneness (High + Critical)")
        ax.set_title("Relationship Between Number of Components and Vulnerability-Proneness (Log Scale)")
        ax.grid(True, linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "scatter_vulnerability_vs_components.pdf")

    def plot_cwe_distribution(self, df):
        """
        Generates and saves a bar plot of the top 15 most common CWE tags.
        """
        cwe_counts = Counter(tag for tags in df['CWE Tags'] for tag in tags)
        cwe_df = pd.DataFrame(cwe_counts.items(), columns=['CWE Tag', 'Frequency']).sort_values(by='Frequency', ascending=False)

        fig, ax = plt.subplots(figsize=(12, 6))
        sns.barplot(data=cwe_df.head(15), x='Frequency', y='CWE Tag', palette='coolwarm', ax=ax)
        ax.set_xlabel("Frequency")
        ax.set_ylabel("CWE Tag")
        ax.set_title("Top 15 Most Common CWE Tags Across Categories")
        ax.grid(axis='x', linestyle='--', alpha=0.6)
        self.results_handler.save_plot(fig, "cwe_distribution.pdf")


    def process_cwe_tags(self, cwe_value, *args):

        # Si ya es una lista, no se modifica
        if isinstance(cwe_value, list):
            return cwe_value
        # Si es una cadena que parece una lista, intenta evaluarla
        elif isinstance(cwe_value, str) and cwe_value.startswith('[') and cwe_value.endswith(']'):
            try:
                return ast.literal_eval(cwe_value)
            except (ValueError, SyntaxError):
                # Si la evaluación falla, retorna una lista vacía o None
                return []
        # Para valores NaN o cualquier otro formato no esperado, retorna lista vacía
        else:
            return []

    def plot_cwe_distribution_by_category(self, df):
        """
        Genera un mapa de burbujas mostrando la relación entre categorías y CWEs.
        """
        # Asegurarse de que 'CWE Tags' está en formato lista de strings
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Crear un DataFrame plano con cada CWE y su categoría asociada
        exploded_df = df.explode('CWE Tags')
        cwe_category_counts = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Obtener el total de acciones por categoría
        category_totals = df['Category'].value_counts().reset_index()
        category_totals.columns = ['Category', 'TotalActions']

        # Combinar el total de acciones con las frecuencias de CWE por categoría
        cwe_category_counts = cwe_category_counts.merge(category_totals, on='Category')

        # Normalizar la columna 'Count' dividiendo por el total de acciones
        cwe_category_counts['NormalizedCount'] = cwe_category_counts['Count'] / cwe_category_counts['TotalActions']

        # Crear el gráfico de burbujas con los valores normalizados
        fig, ax = plt.subplots(figsize=(12, 8))
        scatter = ax.scatter(
            x=cwe_category_counts['Category'],
            y=cwe_category_counts['CWE Tags'],
            s=cwe_category_counts['NormalizedCount'] * 1000,  # Tamaño proporcional a la frecuencia normalizada
            alpha=0.6,
            edgecolors='w',
            linewidth=0.5
        )

        # Configurar ejes y títulos
        ax.set_title('Distribución Normalizada de CWEs por Categoría (Mapa de Burbujas)', fontsize=14)
        ax.set_xlabel('Categoría', fontsize=12)
        ax.set_ylabel('CWE', fontsize=12)
        ax.grid(True, linestyle='--', alpha=0.5)
        plt.xticks(rotation=45, ha='right')

        # Guardar el gráfico
        self.results_handler.save_plot(fig, "cwe_bubble_map_by_category_normalized.pdf")



    def plot_cwe_distribution_by_frequency(self, df, min_frequency=5):
        """
        Generates a horizontal bar chart showing the frequency distribution of CWEs in the dataset.
        """
        # Normalize 'CWE Tags' to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode the DataFrame to work with individual CWEs
        exploded_df = df.explode('CWE Tags')

        # Count the frequency of each CWE
        cwe_counts = exploded_df['CWE Tags'].value_counts().reset_index()
        cwe_counts.columns = ['CWE', 'Count']

        # Filter out low-frequency CWEs for better visualization
        cwe_counts = cwe_counts[cwe_counts['Count'] >= min_frequency]

        # Create the horizontal bar chart
        fig, ax = plt.subplots(figsize=(12, 8))
        sns.barplot(
            data=cwe_counts, 
            x='Count', 
            y='CWE', 
            palette='coolwarm', 
            ax=ax
        )

        # Configure axes and titles
        ax.set_title('CWE Distribution by Frequency (Bar Chart)', fontsize=14)
        ax.set_xlabel('Occurrence Count', fontsize=12)
        ax.set_ylabel('CWE', fontsize=12)
        ax.grid(axis='x', linestyle='--', alpha=0.5)

        # Save the plot
        self.results_handler.save_plot(fig, "cwe_bar_chart_by_frequency.pdf")




    def plot_cwe_distribution_violinplot(self, df, min_frequency=1):
        """
        Generates a violin plot showing the distribution of CWE occurrences across different categories.
        """
        # Normalize 'CWE Tags' to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode the DataFrame to work with individual CWEs
        exploded_df = df.explode('CWE Tags')

        # Count occurrences of each CWE within each category
        cwe_category_counts = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Filter out low-frequency CWEs for better visualization
        cwe_category_counts = cwe_category_counts[cwe_category_counts['Count'] >= min_frequency]

        # Create the violin plot
        fig, ax = plt.subplots(figsize=(14, 8))
        sns.violinplot(
            data=cwe_category_counts, 
            x='Category', 
            y='Count', 
            scale='width', 
            inner='quartile', 
            palette='coolwarm', 
            ax=ax
        )

        # Configure axes and titles
        ax.set_title('CWE Distribution by Category (Violin Plot)', fontsize=14)
        ax.set_xlabel('Category', fontsize=12)
        ax.set_ylabel('CWE Occurrence Count', fontsize=12)
        ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')
        ax.grid(axis='y', linestyle='--', alpha=0.5)

        # Save the plot
        self.results_handler.save_plot(fig, "cwe_violin_plot_by_category.pdf")




    def plot_vulnerability_distribution(self, df):
        """
        Generates histograms and density plots showing the frequency of vulnerabilities per category.
        This visualization helps analyze the prevalence of vulnerabilities across different action categories.
        """
        # Convert 'Total Vulnerabilities' to numeric if not already
        df['Total Vulnerabilities'] = pd.to_numeric(df['Total Vulnerabilities'], errors='coerce')

        # Set up the figure with subplots for histogram and density plot
        fig, axes = plt.subplots(1, 2, figsize=(14, 6), sharex=False)

        # Histogram of total vulnerabilities per category
        sns.histplot(data=df, x='Total Vulnerabilities', hue='Category', bins=30, kde=False, ax=axes[0], multiple="stack")
        axes[0].set_title("Histogram of Total Vulnerabilities per Category")
        axes[0].set_xlabel("Total Vulnerabilities")
        axes[0].set_ylabel("Frequency")
        axes[0].grid(axis='y', linestyle='--', alpha=0.5)

        # Density plot (Kernel Density Estimation) to see the smooth distribution
        sns.kdeplot(data=df, x='Total Vulnerabilities', hue='Category', fill=True, common_norm=False, alpha=0.5, ax=axes[1])
        axes[1].set_title("Density Plot of Vulnerabilities per Category")
        axes[1].set_xlabel("Total Vulnerabilities")
        axes[1].set_ylabel("Density")
        axes[1].grid(axis='y', linestyle='--', alpha=0.5)

        # Adjust layout and save the plot
        plt.tight_layout()
        self.results_handler.save_plot(fig, "vulnerability_distribution_hist_density.pdf")




    def plot_vulnerability_bubble_scatter(self, df):
        """
        Generates a Bubble Map and a Scatter Plot to visualize relationships between categories and vulnerabilities.
        - Bubble Map: Shows normalized vulnerabilities across categories.
        - Scatter Plot: Examines relationships between two vulnerability-related attributes (e.g., Total Vulnerabilities vs. Number of Components).
        """

        # Normalize total vulnerabilities for better scaling in bubble size
        df['Total Vulnerabilities'] = pd.to_numeric(df['Total Vulnerabilities'], errors='coerce')
        df['Normalized Vulnerabilities'] = df.groupby('Category')['Total Vulnerabilities'].transform(lambda x: x / x.max())

        # Set up the figure with subplots
        fig, axes = plt.subplots(1, 2, figsize=(14, 6))

        # ---- Bubble Map (Improved) ----
        bubble_df = df.groupby("Category", as_index=False).agg(
            {"Total Vulnerabilities": "sum", "Number of Components": "mean"}
        )
        bubble_df['Bubble Size'] = bubble_df["Total Vulnerabilities"] / bubble_df["Total Vulnerabilities"].max() * 1000  # Scale size

        sns.scatterplot(
            data=bubble_df,
            x="Category",
            y="Total Vulnerabilities",
            size="Bubble Size",
            sizes=(10, 1000),
            alpha=0.6,
            ax=axes[0]
        )
        axes[0].set_xticklabels(axes[0].get_xticklabels(), rotation=45, ha="right")
        axes[0].set_title("Bubble Map: Normalized Vulnerabilities by Category")
        axes[0].set_xlabel("Category")
        axes[0].set_ylabel("Total Vulnerabilities")
        axes[0].grid(True, linestyle="--", alpha=0.5)

        # ---- Scatter Plot ----
        sns.scatterplot(
            data=df,
            x="Number of Components",
            y="Total Vulnerabilities",
            hue="Category",
            size="Total Vulnerabilities",
            sizes=(10, 300),
            alpha=0.6,
            ax=axes[1]
        )
        axes[1].set_xscale("log")  # Log scale for better visibility if needed
        axes[1].set_yscale("log")
        axes[1].set_title("Scatter Plot: Components vs. Vulnerabilities")
        axes[1].set_xlabel("Number of Components (Log Scale)")
        axes[1].set_ylabel("Total Vulnerabilities (Log Scale)")
        axes[1].grid(True, linestyle="--", alpha=0.5)

        # Adjust layout and save the plot
        plt.tight_layout()
        self.results_handler.save_plot(fig, "vulnerability_bubble_scatter.pdf")



    def plot_cwe_category_heatmap(self, df):
        """
        Generates a heatmap to visualize the intensity of CWEs per category.
        
        - The x-axis represents different vulnerability categories.
        - The y-axis represents CWE tags (types of vulnerabilities).
        - Color intensity indicates the frequency of each CWE in a given category.
        """

        # Ensure 'CWE Tags' is parsed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Create a pivot table counting CWEs per category
        heatmap_data = exploded_df.groupby(['CWE Tags', 'Category']).size().unstack(fill_value=0)

        # Normalize each row by its maximum value for better comparability
        heatmap_data = heatmap_data.div(heatmap_data.max(axis=1), axis=0)

        # Create the heatmap
        fig, ax = plt.subplots(figsize=(12, 8))
        sns.heatmap(heatmap_data, cmap="Blues", linewidths=0.5, linecolor="gray", cbar=True, ax=ax)

        # Format plot
        ax.set_title("Heatmap: Frequency of CWEs per Category", fontsize=14)
        ax.set_xlabel("Category", fontsize=12)
        ax.set_ylabel("CWE Tags", fontsize=12)
        plt.xticks(rotation=45, ha='right')

        # Save plot
        self.results_handler.save_plot(fig, "cwe_category_heatmap.pdf")




    def plot_cwe_category_treemap(self, df):
        """
        Generates a treemap to visualize the hierarchical distribution of CWEs within categories.

        - Each category is represented as a large rectangle.
        - Each CWE within a category is a sub-rectangle.
        - The size of each rectangle represents the frequency of occurrences.
        """

        # Ensure 'CWE Tags' is processed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Count CWEs per category
        treemap_data = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Create a treemap
        fig = px.treemap(treemap_data, 
                        path=['Category', 'CWE Tags'], 
                        values='Count', 
                        color='Count',
                        color_continuous_scale='Blues',
                        title="Treemap: Hierarchical Distribution of CWEs within Categories")

        # Save the plot
        fig.write_image(f"{self.results_handler.results_path}/cwe_category_treemap.pdf")
        print("Treemap saved: cwe_category_treemap.pdf")


    def plot_cwe_category_sunburst(self, df):
        """
        Generates a sunburst chart to visualize the hierarchical structure of CWEs within categories.

        - The inner circle represents categories.
        - The outer circles represent CWEs under those categories.
        - The size of each slice represents the frequency of occurrences.
        """

        # Ensure 'CWE Tags' is processed correctly
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)

        # Explode to create a row per CWE
        exploded_df = df.explode('CWE Tags')

        # Count CWEs per category
        sunburst_data = exploded_df.groupby(['Category', 'CWE Tags']).size().reset_index(name='Count')

        # Create a sunburst chart
        fig = px.sunburst(sunburst_data, 
                        path=['Category', 'CWE Tags'], 
                        values='Count', 
                        color='Count',
                        color_continuous_scale='Blues',
                        title="Sunburst Chart: CWE Hierarchy within Categories")

        # Save the plot
        fig.write_image(f"{self.results_handler.results_path}/cwe_category_sunburst.pdf")
        print("Sunburst Chart saved: cwe_category_sunburst.pdf")


    def plot_cwe_cooccurrence_matrix(self, df, min_occurrences=10):
        """
        Generates a co-occurrence matrix for CWEs, filtering only the most frequent ones.
        """
        import seaborn as sns
        import numpy as np
        import pandas as pd
        from itertools import combinations
        import matplotlib.pyplot as plt
        
        # Convert CWE Tags column to lists
        df['CWE Tags'] = df['CWE Tags'].apply(self.process_cwe_tags)
        
        # Explode CWE Tags to count frequency of each CWE
        all_cwes = df.explode('CWE Tags')['CWE Tags']
        cwe_counts = all_cwes.value_counts()
        
        # Filter CWEs that appear at least 'min_occurrences' times
        frequent_cwes = list(cwe_counts[cwe_counts >= min_occurrences].index)  # Convert to list
        
        # Extract CWE pairs from filtered rows
        cwe_pairs = []
        for cwes in df['CWE Tags']:
            filtered_cwes = [cwe for cwe in cwes if cwe in frequent_cwes]
            cwe_pairs.extend(combinations(filtered_cwes, 2))
        
        # Build co-occurrence matrix
        cwe_cooccurrence = pd.DataFrame(0, index=frequent_cwes, columns=frequent_cwes)
        for cwe1, cwe2 in cwe_pairs:
            cwe_cooccurrence.at[cwe1, cwe2] += 1
            cwe_cooccurrence.at[cwe2, cwe1] += 1  # Symmetric matrix
        
        # Create heatmap figure
        fig, ax = plt.subplots(figsize=(12, 10))  # Ensure 'fig' is properly assigned
        sns.heatmap(cwe_cooccurrence, cmap='Blues', annot=False, linewidths=0.5, ax=ax)
        ax.set_title('CWE Co-Occurrence Matrix (Filtered)')
        plt.xticks(rotation=45, ha='right')
        plt.yticks(rotation=0)
        
        # Save plot using 'fig' instead of 'plt'
        self.results_handler.save_plot(fig, "cwe_cooccurrence_matrix_filtered.pdf")

 

    def plot_vulnerability_proneness_comparison(self, file_path_source, file_path_all):
        """
        Genera un boxplot comparando la Vulnerability-Proneness entre código fuente y dependencias.
        Solo se incluyen categorías con al menos 3 acciones, ordenadas por la mediana.
        Se añaden impresiones de estadísticas descriptivas para diagnosticar diferencias.
        """
        import matplotlib.pyplot as plt
        import seaborn as sns
        import pandas as pd
        import os

        # Configurar estilo y parámetros de matplotlib
        plt.style.use('seaborn-v0_8-darkgrid')
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['Arial']
        plt.rcParams['font.size'] = 12
        plt.rcParams['axes.titlesize'] = 14
        plt.rcParams['axes.labelsize'] = 12

        # Cargar los datasets
        df_source = pd.read_csv(file_path_source)
        df_all = pd.read_csv(file_path_all)
        
        # Imprimir estadísticas descriptivas para diagnosticar diferencias
        print("Estadísticas para Source Only:")
        print(df_source["vulnerability-proneness-source"].describe())
        print("\nEstadísticas para Source + Dependencies:")
        print(df_all["vulnerability-proneness-all"].describe())
        
        # Asignar explícitamente la columna de Vulnerability-Proneness a partir de la columna original de cada archivo
        # Así, el CSV de código fuente usa "vulnerability-proneness-source" y el CSV de dependencias "vulnerability-proneness-all"
        df_source["Vulnerability-Proneness"] = df_source["vulnerability-proneness-source"]
        df_all["Vulnerability-Proneness"] = df_all["vulnerability-proneness-all"]
        
        # Agregar etiquetas para distinguir datasets
        df_source["Data Source"] = "Source Only"
        df_all["Data Source"] = "Source + Dependencies"
        
        # Combinar ambos conjuntos de datos
        df_combined = pd.concat([
            df_source[["Category", "Vulnerability-Proneness", "Data Source"]],
            df_all[["Category", "Vulnerability-Proneness", "Data Source"]]
        ])
        
        # Contar el número de acciones por categoría y filtrar aquellas con al menos 3 acciones
        category_counts = df_combined.groupby('Category').size()
        MIN_ACTIONS = 3
        categories_to_keep = category_counts[category_counts >= MIN_ACTIONS].index
        df_filtered = df_combined[df_combined['Category'].isin(categories_to_keep)]
        
        # Calcular la mediana por categoría y ordenar las categorías según ésta
        category_medians = df_filtered.groupby('Category')['Vulnerability-Proneness'].median().sort_values()
        ordered_categories = category_medians.index
        df_filtered['Category'] = pd.Categorical(df_filtered['Category'], categories=ordered_categories, ordered=True)
        
        # Crear figura con tamaño optimizado y alta resolución
        fig, ax = plt.subplots(figsize=(15, 8), dpi=300)
        
        # Crear el boxplot con mejoras visuales
        sns.boxplot(
            x="Category",
            y="Vulnerability-Proneness",
            hue="Data Source",
            data=df_filtered,
            palette=["#2E86C1", "#E74C3C"],
            width=0.7,
            fliersize=4,
            ax=ax
        )
        
        # Personalizar etiquetas y título
        plt.xlabel("Category", fontweight='bold', labelpad=10)
        plt.ylabel("Vulnerability-Proneness", fontweight='bold', labelpad=10)
        plt.title("Comparison of Vulnerability-Proneness Across Categories\n(Categories with ≥3 actions, sorted by median)", 
                fontweight='bold', pad=20)
        
        # Personalizar la leyenda
        plt.legend(
            title="Data Source",
            title_fontsize=12,
            fontsize=10,
            loc='upper left',
            framealpha=0.9,
            edgecolor='gray'
        )
        
        # Rotar etiquetas del eje x y ajustar layout
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        
        # Guardar el gráfico
        self.results_handler.save_plot(fig, "vulnerability_proneness_comparison.pdf")
        print("Plot saved: vulnerability_proneness_comparison.pdf")
